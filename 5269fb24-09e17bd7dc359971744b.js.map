{"version":3,"file":"5269fb24-09e17bd7dc359971744b.js","mappings":"iIA0BWA,EAoJAC,EAsCAC,EAuCAC,EAqCAC,EA4CAC,E,yCAjTX,SAAWL,GAKPA,EAA0BA,EAAuC,YAAI,GAAK,cAC1EA,EAA0BA,EAAsC,WAAI,GAAK,aAKzEA,EAA0BA,EAAsC,WAAI,GAAK,aACzEA,EAA0BA,EAAuC,YAAI,GAAK,cAK1EA,EAA0BA,EAAsC,WAAI,GAAK,aACzEA,EAA0BA,EAAwC,aAAI,GAAK,eAC3EA,EAA0BA,EAAwC,aAAI,GAAK,eAC3EA,EAA0BA,EAAqC,UAAI,GAAK,YACxEA,EAA0BA,EAAuC,YAAI,GAAK,cAO1EA,EAA0BA,EAAsC,WAAI,IAAM,aAE1EA,EAA0BA,EAAwC,aAAI,IAAM,eAE5EA,EAA0BA,EAAsC,WAAI,IAAM,aAC1EA,EAA0BA,EAAuC,YAAI,IAAM,cAC3EA,EAA0BA,EAAqC,UAAI,IAAM,YACzEA,EAA0BA,EAAyC,cAAI,IAAM,gBAC7EA,EAA0BA,EAAyC,cAAI,IAAM,gBAE7EA,EAA0BA,EAAuC,YAAI,IAAM,cAE3EA,EAA0BA,EAAuC,YAAI,IAAM,cAC3EA,EAA0BA,EAAwC,cAAK,GAAK,cAC/E,CA1CD,CA0CGA,IAA8BA,EAA4B,CAAC,IA0G9D,SAAWC,GAEPA,EAA2BA,EAA2C,eAAI,GAAK,iBAC/EA,EAA2BA,EAA2C,eAAI,GAAK,iBAC/EA,EAA2BA,EAA2C,eAAI,GAAK,iBAC/EA,EAA2BA,EAAyC,cAAK,GAAK,cACjF,CAND,CAMGA,IAA+BA,EAA6B,CAAC,IAgChE,SAAWC,GAEPA,EAAyBA,EAAgC,MAAI,GAAK,QAElEA,EAAyBA,EAAoC,UAAI,GAAK,YAEtEA,EAAyBA,EAAuC,aAAI,GAAK,eACzEA,EAAyBA,EAAuC,cAAK,GAAK,cAC7E,CARD,CAQGA,IAA6BA,EAA2B,CAAC,IA+B5D,SAAWC,GAEPA,EAAmBA,EAA2B,OAAI,GAAK,SACvDA,EAAmBA,EAAyB,KAAI,GAAK,OACrDA,EAAmBA,EAAiC,aAAI,GAAK,eAC7DA,EAAmBA,EAAiC,cAAK,GAAK,cACjE,CAND,CAMGA,IAAuBA,EAAqB,CAAC,IA+BhD,SAAWC,GAEPA,EAAoBA,EAA+B,UAAI,GAAK,YAE5DA,EAAoBA,EAA+B,UAAI,GAAK,YAE5DA,EAAoBA,EAA+B,UAAI,GAAK,YAC5DA,EAAoBA,EAAkC,cAAK,GAAK,cACnE,CARD,CAQGA,IAAwBA,EAAsB,CAAC,IAoClD,SAAWC,GACPA,EAA+BA,EAAoD,oBAAI,GAAK,sBAE5FA,EAA+BA,EAAgD,gBAAI,GAAK,kBAExFA,EAA+BA,EAA2C,WAAI,GAAK,aACnFA,EAA+BA,EAA6C,cAAK,GAAK,cACzF,CAPD,CAOGA,IAAmCA,EAAiC,CAAC,IA8BxE,IAs0JIC,EAAa,WACb,QAA0B,IAAfA,EACP,OAAOA,EACX,GAAoB,oBAATC,KACP,OAAOA,KACX,GAAsB,oBAAXC,OACP,OAAOA,OACX,QAAsB,IAAX,EAAAC,EACP,OAAO,EAAAA,EACX,KAAM,gCACT,CAVgB,GAWNH,EAAWI,KAUXJ,EAAWK,KAuBlB,gBAAkB,MAClB,cAAgB,IAChB,gB","sources":["webpack://wormhole-usdc-demo/./node_modules/@certusone/wormhole-sdk-proto-web/lib/esm/google/protobuf/descriptor.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/* eslint-disable */\nimport Long from \"long\";\nimport _m0 from \"protobufjs/minimal\";\nexport var protobufPackage = \"google.protobuf\";\nexport var FieldDescriptorProto_Type;\n(function (FieldDescriptorProto_Type) {\n    /**\n     * TYPE_DOUBLE - 0 is reserved for errors.\n     * Order is weird for historical reasons.\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_DOUBLE\"] = 1] = \"TYPE_DOUBLE\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FLOAT\"] = 2] = \"TYPE_FLOAT\";\n    /**\n     * TYPE_INT64 - Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n     * negative values are likely.\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_INT64\"] = 3] = \"TYPE_INT64\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_UINT64\"] = 4] = \"TYPE_UINT64\";\n    /**\n     * TYPE_INT32 - Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n     * negative values are likely.\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_INT32\"] = 5] = \"TYPE_INT32\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FIXED64\"] = 6] = \"TYPE_FIXED64\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_FIXED32\"] = 7] = \"TYPE_FIXED32\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_BOOL\"] = 8] = \"TYPE_BOOL\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_STRING\"] = 9] = \"TYPE_STRING\";\n    /**\n     * TYPE_GROUP - Tag-delimited aggregate.\n     * Group type is deprecated and not supported in proto3. However, Proto3\n     * implementations should still be able to parse the group wire format and\n     * treat group fields as unknown fields.\n     */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_GROUP\"] = 10] = \"TYPE_GROUP\";\n    /** TYPE_MESSAGE - Length-delimited aggregate. */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_MESSAGE\"] = 11] = \"TYPE_MESSAGE\";\n    /** TYPE_BYTES - New in version 2. */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_BYTES\"] = 12] = \"TYPE_BYTES\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_UINT32\"] = 13] = \"TYPE_UINT32\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_ENUM\"] = 14] = \"TYPE_ENUM\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SFIXED32\"] = 15] = \"TYPE_SFIXED32\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SFIXED64\"] = 16] = \"TYPE_SFIXED64\";\n    /** TYPE_SINT32 - Uses ZigZag encoding. */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SINT32\"] = 17] = \"TYPE_SINT32\";\n    /** TYPE_SINT64 - Uses ZigZag encoding. */\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"TYPE_SINT64\"] = 18] = \"TYPE_SINT64\";\n    FieldDescriptorProto_Type[FieldDescriptorProto_Type[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));\nexport function fieldDescriptorProto_TypeFromJSON(object) {\n    switch (object) {\n        case 1:\n        case \"TYPE_DOUBLE\":\n            return FieldDescriptorProto_Type.TYPE_DOUBLE;\n        case 2:\n        case \"TYPE_FLOAT\":\n            return FieldDescriptorProto_Type.TYPE_FLOAT;\n        case 3:\n        case \"TYPE_INT64\":\n            return FieldDescriptorProto_Type.TYPE_INT64;\n        case 4:\n        case \"TYPE_UINT64\":\n            return FieldDescriptorProto_Type.TYPE_UINT64;\n        case 5:\n        case \"TYPE_INT32\":\n            return FieldDescriptorProto_Type.TYPE_INT32;\n        case 6:\n        case \"TYPE_FIXED64\":\n            return FieldDescriptorProto_Type.TYPE_FIXED64;\n        case 7:\n        case \"TYPE_FIXED32\":\n            return FieldDescriptorProto_Type.TYPE_FIXED32;\n        case 8:\n        case \"TYPE_BOOL\":\n            return FieldDescriptorProto_Type.TYPE_BOOL;\n        case 9:\n        case \"TYPE_STRING\":\n            return FieldDescriptorProto_Type.TYPE_STRING;\n        case 10:\n        case \"TYPE_GROUP\":\n            return FieldDescriptorProto_Type.TYPE_GROUP;\n        case 11:\n        case \"TYPE_MESSAGE\":\n            return FieldDescriptorProto_Type.TYPE_MESSAGE;\n        case 12:\n        case \"TYPE_BYTES\":\n            return FieldDescriptorProto_Type.TYPE_BYTES;\n        case 13:\n        case \"TYPE_UINT32\":\n            return FieldDescriptorProto_Type.TYPE_UINT32;\n        case 14:\n        case \"TYPE_ENUM\":\n            return FieldDescriptorProto_Type.TYPE_ENUM;\n        case 15:\n        case \"TYPE_SFIXED32\":\n            return FieldDescriptorProto_Type.TYPE_SFIXED32;\n        case 16:\n        case \"TYPE_SFIXED64\":\n            return FieldDescriptorProto_Type.TYPE_SFIXED64;\n        case 17:\n        case \"TYPE_SINT32\":\n            return FieldDescriptorProto_Type.TYPE_SINT32;\n        case 18:\n        case \"TYPE_SINT64\":\n            return FieldDescriptorProto_Type.TYPE_SINT64;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return FieldDescriptorProto_Type.UNRECOGNIZED;\n    }\n}\nexport function fieldDescriptorProto_TypeToJSON(object) {\n    switch (object) {\n        case FieldDescriptorProto_Type.TYPE_DOUBLE:\n            return \"TYPE_DOUBLE\";\n        case FieldDescriptorProto_Type.TYPE_FLOAT:\n            return \"TYPE_FLOAT\";\n        case FieldDescriptorProto_Type.TYPE_INT64:\n            return \"TYPE_INT64\";\n        case FieldDescriptorProto_Type.TYPE_UINT64:\n            return \"TYPE_UINT64\";\n        case FieldDescriptorProto_Type.TYPE_INT32:\n            return \"TYPE_INT32\";\n        case FieldDescriptorProto_Type.TYPE_FIXED64:\n            return \"TYPE_FIXED64\";\n        case FieldDescriptorProto_Type.TYPE_FIXED32:\n            return \"TYPE_FIXED32\";\n        case FieldDescriptorProto_Type.TYPE_BOOL:\n            return \"TYPE_BOOL\";\n        case FieldDescriptorProto_Type.TYPE_STRING:\n            return \"TYPE_STRING\";\n        case FieldDescriptorProto_Type.TYPE_GROUP:\n            return \"TYPE_GROUP\";\n        case FieldDescriptorProto_Type.TYPE_MESSAGE:\n            return \"TYPE_MESSAGE\";\n        case FieldDescriptorProto_Type.TYPE_BYTES:\n            return \"TYPE_BYTES\";\n        case FieldDescriptorProto_Type.TYPE_UINT32:\n            return \"TYPE_UINT32\";\n        case FieldDescriptorProto_Type.TYPE_ENUM:\n            return \"TYPE_ENUM\";\n        case FieldDescriptorProto_Type.TYPE_SFIXED32:\n            return \"TYPE_SFIXED32\";\n        case FieldDescriptorProto_Type.TYPE_SFIXED64:\n            return \"TYPE_SFIXED64\";\n        case FieldDescriptorProto_Type.TYPE_SINT32:\n            return \"TYPE_SINT32\";\n        case FieldDescriptorProto_Type.TYPE_SINT64:\n            return \"TYPE_SINT64\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexport var FieldDescriptorProto_Label;\n(function (FieldDescriptorProto_Label) {\n    /** LABEL_OPTIONAL - 0 is reserved for errors */\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_OPTIONAL\"] = 1] = \"LABEL_OPTIONAL\";\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_REQUIRED\"] = 2] = \"LABEL_REQUIRED\";\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"LABEL_REPEATED\"] = 3] = \"LABEL_REPEATED\";\n    FieldDescriptorProto_Label[FieldDescriptorProto_Label[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));\nexport function fieldDescriptorProto_LabelFromJSON(object) {\n    switch (object) {\n        case 1:\n        case \"LABEL_OPTIONAL\":\n            return FieldDescriptorProto_Label.LABEL_OPTIONAL;\n        case 2:\n        case \"LABEL_REQUIRED\":\n            return FieldDescriptorProto_Label.LABEL_REQUIRED;\n        case 3:\n        case \"LABEL_REPEATED\":\n            return FieldDescriptorProto_Label.LABEL_REPEATED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return FieldDescriptorProto_Label.UNRECOGNIZED;\n    }\n}\nexport function fieldDescriptorProto_LabelToJSON(object) {\n    switch (object) {\n        case FieldDescriptorProto_Label.LABEL_OPTIONAL:\n            return \"LABEL_OPTIONAL\";\n        case FieldDescriptorProto_Label.LABEL_REQUIRED:\n            return \"LABEL_REQUIRED\";\n        case FieldDescriptorProto_Label.LABEL_REPEATED:\n            return \"LABEL_REPEATED\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\n/** Generated classes can be optimized for speed or code size. */\nexport var FileOptions_OptimizeMode;\n(function (FileOptions_OptimizeMode) {\n    /** SPEED - Generate complete code for parsing, serialization, */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"SPEED\"] = 1] = \"SPEED\";\n    /** CODE_SIZE - etc. */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"CODE_SIZE\"] = 2] = \"CODE_SIZE\";\n    /** LITE_RUNTIME - Generate code using MessageLite and the lite runtime. */\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"LITE_RUNTIME\"] = 3] = \"LITE_RUNTIME\";\n    FileOptions_OptimizeMode[FileOptions_OptimizeMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));\nexport function fileOptions_OptimizeModeFromJSON(object) {\n    switch (object) {\n        case 1:\n        case \"SPEED\":\n            return FileOptions_OptimizeMode.SPEED;\n        case 2:\n        case \"CODE_SIZE\":\n            return FileOptions_OptimizeMode.CODE_SIZE;\n        case 3:\n        case \"LITE_RUNTIME\":\n            return FileOptions_OptimizeMode.LITE_RUNTIME;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return FileOptions_OptimizeMode.UNRECOGNIZED;\n    }\n}\nexport function fileOptions_OptimizeModeToJSON(object) {\n    switch (object) {\n        case FileOptions_OptimizeMode.SPEED:\n            return \"SPEED\";\n        case FileOptions_OptimizeMode.CODE_SIZE:\n            return \"CODE_SIZE\";\n        case FileOptions_OptimizeMode.LITE_RUNTIME:\n            return \"LITE_RUNTIME\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexport var FieldOptions_CType;\n(function (FieldOptions_CType) {\n    /** STRING - Default mode. */\n    FieldOptions_CType[FieldOptions_CType[\"STRING\"] = 0] = \"STRING\";\n    FieldOptions_CType[FieldOptions_CType[\"CORD\"] = 1] = \"CORD\";\n    FieldOptions_CType[FieldOptions_CType[\"STRING_PIECE\"] = 2] = \"STRING_PIECE\";\n    FieldOptions_CType[FieldOptions_CType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldOptions_CType || (FieldOptions_CType = {}));\nexport function fieldOptions_CTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"STRING\":\n            return FieldOptions_CType.STRING;\n        case 1:\n        case \"CORD\":\n            return FieldOptions_CType.CORD;\n        case 2:\n        case \"STRING_PIECE\":\n            return FieldOptions_CType.STRING_PIECE;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return FieldOptions_CType.UNRECOGNIZED;\n    }\n}\nexport function fieldOptions_CTypeToJSON(object) {\n    switch (object) {\n        case FieldOptions_CType.STRING:\n            return \"STRING\";\n        case FieldOptions_CType.CORD:\n            return \"CORD\";\n        case FieldOptions_CType.STRING_PIECE:\n            return \"STRING_PIECE\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexport var FieldOptions_JSType;\n(function (FieldOptions_JSType) {\n    /** JS_NORMAL - Use the default type. */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_NORMAL\"] = 0] = \"JS_NORMAL\";\n    /** JS_STRING - Use JavaScript strings. */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_STRING\"] = 1] = \"JS_STRING\";\n    /** JS_NUMBER - Use JavaScript numbers. */\n    FieldOptions_JSType[FieldOptions_JSType[\"JS_NUMBER\"] = 2] = \"JS_NUMBER\";\n    FieldOptions_JSType[FieldOptions_JSType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(FieldOptions_JSType || (FieldOptions_JSType = {}));\nexport function fieldOptions_JSTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"JS_NORMAL\":\n            return FieldOptions_JSType.JS_NORMAL;\n        case 1:\n        case \"JS_STRING\":\n            return FieldOptions_JSType.JS_STRING;\n        case 2:\n        case \"JS_NUMBER\":\n            return FieldOptions_JSType.JS_NUMBER;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return FieldOptions_JSType.UNRECOGNIZED;\n    }\n}\nexport function fieldOptions_JSTypeToJSON(object) {\n    switch (object) {\n        case FieldOptions_JSType.JS_NORMAL:\n            return \"JS_NORMAL\";\n        case FieldOptions_JSType.JS_STRING:\n            return \"JS_STRING\";\n        case FieldOptions_JSType.JS_NUMBER:\n            return \"JS_NUMBER\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\n/**\n * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,\n * or neither? HTTP based RPC implementation may choose GET verb for safe\n * methods, and PUT verb for idempotent methods instead of the default POST.\n */\nexport var MethodOptions_IdempotencyLevel;\n(function (MethodOptions_IdempotencyLevel) {\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = 0] = \"IDEMPOTENCY_UNKNOWN\";\n    /** NO_SIDE_EFFECTS - implies idempotent */\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = 1] = \"NO_SIDE_EFFECTS\";\n    /** IDEMPOTENT - idempotent, but may have side effects */\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"IDEMPOTENT\"] = 2] = \"IDEMPOTENT\";\n    MethodOptions_IdempotencyLevel[MethodOptions_IdempotencyLevel[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));\nexport function methodOptions_IdempotencyLevelFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"IDEMPOTENCY_UNKNOWN\":\n            return MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN;\n        case 1:\n        case \"NO_SIDE_EFFECTS\":\n            return MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS;\n        case 2:\n        case \"IDEMPOTENT\":\n            return MethodOptions_IdempotencyLevel.IDEMPOTENT;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return MethodOptions_IdempotencyLevel.UNRECOGNIZED;\n    }\n}\nexport function methodOptions_IdempotencyLevelToJSON(object) {\n    switch (object) {\n        case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:\n            return \"IDEMPOTENCY_UNKNOWN\";\n        case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:\n            return \"NO_SIDE_EFFECTS\";\n        case MethodOptions_IdempotencyLevel.IDEMPOTENT:\n            return \"IDEMPOTENT\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nvar baseFileDescriptorSet = {};\nexport var FileDescriptorSet = {\n    encode: function (message, writer) {\n        var e_1, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.file), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                FileDescriptorProto.encode(v, writer.uint32(10).fork()).ldelim();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseFileDescriptorSet);\n        message.file = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.file.push(FileDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_2, _a;\n        var message = __assign({}, baseFileDescriptorSet);\n        message.file = [];\n        if (object.file !== undefined && object.file !== null) {\n            try {\n                for (var _b = __values(object.file), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.file.push(FileDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.file) {\n            obj.file = message.file.map(function (e) {\n                return e ? FileDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.file = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_3, _a;\n        var message = __assign({}, baseFileDescriptorSet);\n        message.file = [];\n        if (object.file !== undefined && object.file !== null) {\n            try {\n                for (var _b = __values(object.file), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.file.push(FileDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseFileDescriptorProto = {\n    name: \"\",\n    package: \"\",\n    dependency: \"\",\n    publicDependency: 0,\n    weakDependency: 0,\n    syntax: \"\",\n};\nexport var FileDescriptorProto = {\n    encode: function (message, writer) {\n        var e_4, _a, e_5, _b, e_6, _c, e_7, _d, e_8, _e, e_9, _f, e_10, _g;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.package !== \"\") {\n            writer.uint32(18).string(message.package);\n        }\n        try {\n            for (var _h = __values(message.dependency), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var v = _j.value;\n                writer.uint32(26).string(v);\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        writer.uint32(82).fork();\n        try {\n            for (var _k = __values(message.publicDependency), _l = _k.next(); !_l.done; _l = _k.next()) {\n                var v = _l.value;\n                writer.int32(v);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_l && !_l.done && (_b = _k.return)) _b.call(_k);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        writer.ldelim();\n        writer.uint32(90).fork();\n        try {\n            for (var _m = __values(message.weakDependency), _o = _m.next(); !_o.done; _o = _m.next()) {\n                var v = _o.value;\n                writer.int32(v);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_o && !_o.done && (_c = _m.return)) _c.call(_m);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        writer.ldelim();\n        try {\n            for (var _p = __values(message.messageType), _q = _p.next(); !_q.done; _q = _p.next()) {\n                var v = _q.value;\n                DescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (_q && !_q.done && (_d = _p.return)) _d.call(_p);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        try {\n            for (var _r = __values(message.enumType), _s = _r.next(); !_s.done; _s = _r.next()) {\n                var v = _s.value;\n                EnumDescriptorProto.encode(v, writer.uint32(42).fork()).ldelim();\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (_s && !_s.done && (_e = _r.return)) _e.call(_r);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        try {\n            for (var _t = __values(message.service), _u = _t.next(); !_u.done; _u = _t.next()) {\n                var v = _u.value;\n                ServiceDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (_u && !_u.done && (_f = _t.return)) _f.call(_t);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        try {\n            for (var _v = __values(message.extension), _w = _v.next(); !_w.done; _w = _v.next()) {\n                var v = _w.value;\n                FieldDescriptorProto.encode(v, writer.uint32(58).fork()).ldelim();\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (_w && !_w.done && (_g = _v.return)) _g.call(_v);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n        if (message.options !== undefined) {\n            FileOptions.encode(message.options, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.sourceCodeInfo !== undefined) {\n            SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(74).fork()).ldelim();\n        }\n        if (message.syntax !== \"\") {\n            writer.uint32(98).string(message.syntax);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseFileDescriptorProto);\n        message.dependency = [];\n        message.publicDependency = [];\n        message.weakDependency = [];\n        message.messageType = [];\n        message.enumType = [];\n        message.service = [];\n        message.extension = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.package = reader.string();\n                    break;\n                case 3:\n                    message.dependency.push(reader.string());\n                    break;\n                case 10:\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.publicDependency.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.publicDependency.push(reader.int32());\n                    }\n                    break;\n                case 11:\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.weakDependency.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.weakDependency.push(reader.int32());\n                    }\n                    break;\n                case 4:\n                    message.messageType.push(DescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.service.push(ServiceDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 8:\n                    message.options = FileOptions.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.sourceCodeInfo = SourceCodeInfo.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.syntax = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_11, _a, e_12, _b, e_13, _c, e_14, _d, e_15, _e, e_16, _f, e_17, _g;\n        var message = __assign({}, baseFileDescriptorProto);\n        message.dependency = [];\n        message.publicDependency = [];\n        message.weakDependency = [];\n        message.messageType = [];\n        message.enumType = [];\n        message.service = [];\n        message.extension = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.package !== undefined && object.package !== null) {\n            message.package = String(object.package);\n        }\n        else {\n            message.package = \"\";\n        }\n        if (object.dependency !== undefined && object.dependency !== null) {\n            try {\n                for (var _h = __values(object.dependency), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.dependency.push(String(e));\n                }\n            }\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n                }\n                finally { if (e_11) throw e_11.error; }\n            }\n        }\n        if (object.publicDependency !== undefined &&\n            object.publicDependency !== null) {\n            try {\n                for (var _k = __values(object.publicDependency), _l = _k.next(); !_l.done; _l = _k.next()) {\n                    var e = _l.value;\n                    message.publicDependency.push(Number(e));\n                }\n            }\n            catch (e_12_1) { e_12 = { error: e_12_1 }; }\n            finally {\n                try {\n                    if (_l && !_l.done && (_b = _k.return)) _b.call(_k);\n                }\n                finally { if (e_12) throw e_12.error; }\n            }\n        }\n        if (object.weakDependency !== undefined && object.weakDependency !== null) {\n            try {\n                for (var _m = __values(object.weakDependency), _o = _m.next(); !_o.done; _o = _m.next()) {\n                    var e = _o.value;\n                    message.weakDependency.push(Number(e));\n                }\n            }\n            catch (e_13_1) { e_13 = { error: e_13_1 }; }\n            finally {\n                try {\n                    if (_o && !_o.done && (_c = _m.return)) _c.call(_m);\n                }\n                finally { if (e_13) throw e_13.error; }\n            }\n        }\n        if (object.messageType !== undefined && object.messageType !== null) {\n            try {\n                for (var _p = __values(object.messageType), _q = _p.next(); !_q.done; _q = _p.next()) {\n                    var e = _q.value;\n                    message.messageType.push(DescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_14_1) { e_14 = { error: e_14_1 }; }\n            finally {\n                try {\n                    if (_q && !_q.done && (_d = _p.return)) _d.call(_p);\n                }\n                finally { if (e_14) throw e_14.error; }\n            }\n        }\n        if (object.enumType !== undefined && object.enumType !== null) {\n            try {\n                for (var _r = __values(object.enumType), _s = _r.next(); !_s.done; _s = _r.next()) {\n                    var e = _s.value;\n                    message.enumType.push(EnumDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_15_1) { e_15 = { error: e_15_1 }; }\n            finally {\n                try {\n                    if (_s && !_s.done && (_e = _r.return)) _e.call(_r);\n                }\n                finally { if (e_15) throw e_15.error; }\n            }\n        }\n        if (object.service !== undefined && object.service !== null) {\n            try {\n                for (var _t = __values(object.service), _u = _t.next(); !_u.done; _u = _t.next()) {\n                    var e = _u.value;\n                    message.service.push(ServiceDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_16_1) { e_16 = { error: e_16_1 }; }\n            finally {\n                try {\n                    if (_u && !_u.done && (_f = _t.return)) _f.call(_t);\n                }\n                finally { if (e_16) throw e_16.error; }\n            }\n        }\n        if (object.extension !== undefined && object.extension !== null) {\n            try {\n                for (var _v = __values(object.extension), _w = _v.next(); !_w.done; _w = _v.next()) {\n                    var e = _w.value;\n                    message.extension.push(FieldDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_17_1) { e_17 = { error: e_17_1 }; }\n            finally {\n                try {\n                    if (_w && !_w.done && (_g = _v.return)) _g.call(_v);\n                }\n                finally { if (e_17) throw e_17.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = FileOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.sourceCodeInfo !== undefined && object.sourceCodeInfo !== null) {\n            message.sourceCodeInfo = SourceCodeInfo.fromJSON(object.sourceCodeInfo);\n        }\n        else {\n            message.sourceCodeInfo = undefined;\n        }\n        if (object.syntax !== undefined && object.syntax !== null) {\n            message.syntax = String(object.syntax);\n        }\n        else {\n            message.syntax = \"\";\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.package !== undefined && (obj.package = message.package);\n        if (message.dependency) {\n            obj.dependency = message.dependency.map(function (e) { return e; });\n        }\n        else {\n            obj.dependency = [];\n        }\n        if (message.publicDependency) {\n            obj.publicDependency = message.publicDependency.map(function (e) { return e; });\n        }\n        else {\n            obj.publicDependency = [];\n        }\n        if (message.weakDependency) {\n            obj.weakDependency = message.weakDependency.map(function (e) { return e; });\n        }\n        else {\n            obj.weakDependency = [];\n        }\n        if (message.messageType) {\n            obj.messageType = message.messageType.map(function (e) {\n                return e ? DescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.messageType = [];\n        }\n        if (message.enumType) {\n            obj.enumType = message.enumType.map(function (e) {\n                return e ? EnumDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.enumType = [];\n        }\n        if (message.service) {\n            obj.service = message.service.map(function (e) {\n                return e ? ServiceDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.service = [];\n        }\n        if (message.extension) {\n            obj.extension = message.extension.map(function (e) {\n                return e ? FieldDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.extension = [];\n        }\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? FileOptions.toJSON(message.options)\n                : undefined);\n        message.sourceCodeInfo !== undefined &&\n            (obj.sourceCodeInfo = message.sourceCodeInfo\n                ? SourceCodeInfo.toJSON(message.sourceCodeInfo)\n                : undefined);\n        message.syntax !== undefined && (obj.syntax = message.syntax);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_18, _a, e_19, _b, e_20, _c, e_21, _d, e_22, _e, e_23, _f, e_24, _g;\n        var message = __assign({}, baseFileDescriptorProto);\n        message.dependency = [];\n        message.publicDependency = [];\n        message.weakDependency = [];\n        message.messageType = [];\n        message.enumType = [];\n        message.service = [];\n        message.extension = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.package !== undefined && object.package !== null) {\n            message.package = object.package;\n        }\n        else {\n            message.package = \"\";\n        }\n        if (object.dependency !== undefined && object.dependency !== null) {\n            try {\n                for (var _h = __values(object.dependency), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.dependency.push(e);\n                }\n            }\n            catch (e_18_1) { e_18 = { error: e_18_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n                }\n                finally { if (e_18) throw e_18.error; }\n            }\n        }\n        if (object.publicDependency !== undefined &&\n            object.publicDependency !== null) {\n            try {\n                for (var _k = __values(object.publicDependency), _l = _k.next(); !_l.done; _l = _k.next()) {\n                    var e = _l.value;\n                    message.publicDependency.push(e);\n                }\n            }\n            catch (e_19_1) { e_19 = { error: e_19_1 }; }\n            finally {\n                try {\n                    if (_l && !_l.done && (_b = _k.return)) _b.call(_k);\n                }\n                finally { if (e_19) throw e_19.error; }\n            }\n        }\n        if (object.weakDependency !== undefined && object.weakDependency !== null) {\n            try {\n                for (var _m = __values(object.weakDependency), _o = _m.next(); !_o.done; _o = _m.next()) {\n                    var e = _o.value;\n                    message.weakDependency.push(e);\n                }\n            }\n            catch (e_20_1) { e_20 = { error: e_20_1 }; }\n            finally {\n                try {\n                    if (_o && !_o.done && (_c = _m.return)) _c.call(_m);\n                }\n                finally { if (e_20) throw e_20.error; }\n            }\n        }\n        if (object.messageType !== undefined && object.messageType !== null) {\n            try {\n                for (var _p = __values(object.messageType), _q = _p.next(); !_q.done; _q = _p.next()) {\n                    var e = _q.value;\n                    message.messageType.push(DescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_21_1) { e_21 = { error: e_21_1 }; }\n            finally {\n                try {\n                    if (_q && !_q.done && (_d = _p.return)) _d.call(_p);\n                }\n                finally { if (e_21) throw e_21.error; }\n            }\n        }\n        if (object.enumType !== undefined && object.enumType !== null) {\n            try {\n                for (var _r = __values(object.enumType), _s = _r.next(); !_s.done; _s = _r.next()) {\n                    var e = _s.value;\n                    message.enumType.push(EnumDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_22_1) { e_22 = { error: e_22_1 }; }\n            finally {\n                try {\n                    if (_s && !_s.done && (_e = _r.return)) _e.call(_r);\n                }\n                finally { if (e_22) throw e_22.error; }\n            }\n        }\n        if (object.service !== undefined && object.service !== null) {\n            try {\n                for (var _t = __values(object.service), _u = _t.next(); !_u.done; _u = _t.next()) {\n                    var e = _u.value;\n                    message.service.push(ServiceDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_23_1) { e_23 = { error: e_23_1 }; }\n            finally {\n                try {\n                    if (_u && !_u.done && (_f = _t.return)) _f.call(_t);\n                }\n                finally { if (e_23) throw e_23.error; }\n            }\n        }\n        if (object.extension !== undefined && object.extension !== null) {\n            try {\n                for (var _v = __values(object.extension), _w = _v.next(); !_w.done; _w = _v.next()) {\n                    var e = _w.value;\n                    message.extension.push(FieldDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_24_1) { e_24 = { error: e_24_1 }; }\n            finally {\n                try {\n                    if (_w && !_w.done && (_g = _v.return)) _g.call(_v);\n                }\n                finally { if (e_24) throw e_24.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = FileOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.sourceCodeInfo !== undefined && object.sourceCodeInfo !== null) {\n            message.sourceCodeInfo = SourceCodeInfo.fromPartial(object.sourceCodeInfo);\n        }\n        else {\n            message.sourceCodeInfo = undefined;\n        }\n        if (object.syntax !== undefined && object.syntax !== null) {\n            message.syntax = object.syntax;\n        }\n        else {\n            message.syntax = \"\";\n        }\n        return message;\n    },\n};\nvar baseDescriptorProto = { name: \"\", reservedName: \"\" };\nexport var DescriptorProto = {\n    encode: function (message, writer) {\n        var e_25, _a, e_26, _b, e_27, _c, e_28, _d, e_29, _e, e_30, _f, e_31, _g, e_32, _h;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        try {\n            for (var _j = __values(message.field), _k = _j.next(); !_k.done; _k = _j.next()) {\n                var v = _k.value;\n                FieldDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n            }\n        }\n        catch (e_25_1) { e_25 = { error: e_25_1 }; }\n        finally {\n            try {\n                if (_k && !_k.done && (_a = _j.return)) _a.call(_j);\n            }\n            finally { if (e_25) throw e_25.error; }\n        }\n        try {\n            for (var _l = __values(message.extension), _m = _l.next(); !_m.done; _m = _l.next()) {\n                var v = _m.value;\n                FieldDescriptorProto.encode(v, writer.uint32(50).fork()).ldelim();\n            }\n        }\n        catch (e_26_1) { e_26 = { error: e_26_1 }; }\n        finally {\n            try {\n                if (_m && !_m.done && (_b = _l.return)) _b.call(_l);\n            }\n            finally { if (e_26) throw e_26.error; }\n        }\n        try {\n            for (var _o = __values(message.nestedType), _p = _o.next(); !_p.done; _p = _o.next()) {\n                var v = _p.value;\n                DescriptorProto.encode(v, writer.uint32(26).fork()).ldelim();\n            }\n        }\n        catch (e_27_1) { e_27 = { error: e_27_1 }; }\n        finally {\n            try {\n                if (_p && !_p.done && (_c = _o.return)) _c.call(_o);\n            }\n            finally { if (e_27) throw e_27.error; }\n        }\n        try {\n            for (var _q = __values(message.enumType), _r = _q.next(); !_r.done; _r = _q.next()) {\n                var v = _r.value;\n                EnumDescriptorProto.encode(v, writer.uint32(34).fork()).ldelim();\n            }\n        }\n        catch (e_28_1) { e_28 = { error: e_28_1 }; }\n        finally {\n            try {\n                if (_r && !_r.done && (_d = _q.return)) _d.call(_q);\n            }\n            finally { if (e_28) throw e_28.error; }\n        }\n        try {\n            for (var _s = __values(message.extensionRange), _t = _s.next(); !_t.done; _t = _s.next()) {\n                var v = _t.value;\n                DescriptorProto_ExtensionRange.encode(v, writer.uint32(42).fork()).ldelim();\n            }\n        }\n        catch (e_29_1) { e_29 = { error: e_29_1 }; }\n        finally {\n            try {\n                if (_t && !_t.done && (_e = _s.return)) _e.call(_s);\n            }\n            finally { if (e_29) throw e_29.error; }\n        }\n        try {\n            for (var _u = __values(message.oneofDecl), _v = _u.next(); !_v.done; _v = _u.next()) {\n                var v = _v.value;\n                OneofDescriptorProto.encode(v, writer.uint32(66).fork()).ldelim();\n            }\n        }\n        catch (e_30_1) { e_30 = { error: e_30_1 }; }\n        finally {\n            try {\n                if (_v && !_v.done && (_f = _u.return)) _f.call(_u);\n            }\n            finally { if (e_30) throw e_30.error; }\n        }\n        if (message.options !== undefined) {\n            MessageOptions.encode(message.options, writer.uint32(58).fork()).ldelim();\n        }\n        try {\n            for (var _w = __values(message.reservedRange), _x = _w.next(); !_x.done; _x = _w.next()) {\n                var v = _x.value;\n                DescriptorProto_ReservedRange.encode(v, writer.uint32(74).fork()).ldelim();\n            }\n        }\n        catch (e_31_1) { e_31 = { error: e_31_1 }; }\n        finally {\n            try {\n                if (_x && !_x.done && (_g = _w.return)) _g.call(_w);\n            }\n            finally { if (e_31) throw e_31.error; }\n        }\n        try {\n            for (var _y = __values(message.reservedName), _z = _y.next(); !_z.done; _z = _y.next()) {\n                var v = _z.value;\n                writer.uint32(82).string(v);\n            }\n        }\n        catch (e_32_1) { e_32 = { error: e_32_1 }; }\n        finally {\n            try {\n                if (_z && !_z.done && (_h = _y.return)) _h.call(_y);\n            }\n            finally { if (e_32) throw e_32.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseDescriptorProto);\n        message.field = [];\n        message.extension = [];\n        message.nestedType = [];\n        message.enumType = [];\n        message.extensionRange = [];\n        message.oneofDecl = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.field.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.extension.push(FieldDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.nestedType.push(DescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.enumType.push(EnumDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.extensionRange.push(DescriptorProto_ExtensionRange.decode(reader, reader.uint32()));\n                    break;\n                case 8:\n                    message.oneofDecl.push(OneofDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.options = MessageOptions.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.reservedRange.push(DescriptorProto_ReservedRange.decode(reader, reader.uint32()));\n                    break;\n                case 10:\n                    message.reservedName.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_33, _a, e_34, _b, e_35, _c, e_36, _d, e_37, _e, e_38, _f, e_39, _g, e_40, _h;\n        var message = __assign({}, baseDescriptorProto);\n        message.field = [];\n        message.extension = [];\n        message.nestedType = [];\n        message.enumType = [];\n        message.extensionRange = [];\n        message.oneofDecl = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.field !== undefined && object.field !== null) {\n            try {\n                for (var _j = __values(object.field), _k = _j.next(); !_k.done; _k = _j.next()) {\n                    var e = _k.value;\n                    message.field.push(FieldDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_33_1) { e_33 = { error: e_33_1 }; }\n            finally {\n                try {\n                    if (_k && !_k.done && (_a = _j.return)) _a.call(_j);\n                }\n                finally { if (e_33) throw e_33.error; }\n            }\n        }\n        if (object.extension !== undefined && object.extension !== null) {\n            try {\n                for (var _l = __values(object.extension), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var e = _m.value;\n                    message.extension.push(FieldDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_34_1) { e_34 = { error: e_34_1 }; }\n            finally {\n                try {\n                    if (_m && !_m.done && (_b = _l.return)) _b.call(_l);\n                }\n                finally { if (e_34) throw e_34.error; }\n            }\n        }\n        if (object.nestedType !== undefined && object.nestedType !== null) {\n            try {\n                for (var _o = __values(object.nestedType), _p = _o.next(); !_p.done; _p = _o.next()) {\n                    var e = _p.value;\n                    message.nestedType.push(DescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_35_1) { e_35 = { error: e_35_1 }; }\n            finally {\n                try {\n                    if (_p && !_p.done && (_c = _o.return)) _c.call(_o);\n                }\n                finally { if (e_35) throw e_35.error; }\n            }\n        }\n        if (object.enumType !== undefined && object.enumType !== null) {\n            try {\n                for (var _q = __values(object.enumType), _r = _q.next(); !_r.done; _r = _q.next()) {\n                    var e = _r.value;\n                    message.enumType.push(EnumDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_36_1) { e_36 = { error: e_36_1 }; }\n            finally {\n                try {\n                    if (_r && !_r.done && (_d = _q.return)) _d.call(_q);\n                }\n                finally { if (e_36) throw e_36.error; }\n            }\n        }\n        if (object.extensionRange !== undefined && object.extensionRange !== null) {\n            try {\n                for (var _s = __values(object.extensionRange), _t = _s.next(); !_t.done; _t = _s.next()) {\n                    var e = _t.value;\n                    message.extensionRange.push(DescriptorProto_ExtensionRange.fromJSON(e));\n                }\n            }\n            catch (e_37_1) { e_37 = { error: e_37_1 }; }\n            finally {\n                try {\n                    if (_t && !_t.done && (_e = _s.return)) _e.call(_s);\n                }\n                finally { if (e_37) throw e_37.error; }\n            }\n        }\n        if (object.oneofDecl !== undefined && object.oneofDecl !== null) {\n            try {\n                for (var _u = __values(object.oneofDecl), _v = _u.next(); !_v.done; _v = _u.next()) {\n                    var e = _v.value;\n                    message.oneofDecl.push(OneofDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_38_1) { e_38 = { error: e_38_1 }; }\n            finally {\n                try {\n                    if (_v && !_v.done && (_f = _u.return)) _f.call(_u);\n                }\n                finally { if (e_38) throw e_38.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = MessageOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.reservedRange !== undefined && object.reservedRange !== null) {\n            try {\n                for (var _w = __values(object.reservedRange), _x = _w.next(); !_x.done; _x = _w.next()) {\n                    var e = _x.value;\n                    message.reservedRange.push(DescriptorProto_ReservedRange.fromJSON(e));\n                }\n            }\n            catch (e_39_1) { e_39 = { error: e_39_1 }; }\n            finally {\n                try {\n                    if (_x && !_x.done && (_g = _w.return)) _g.call(_w);\n                }\n                finally { if (e_39) throw e_39.error; }\n            }\n        }\n        if (object.reservedName !== undefined && object.reservedName !== null) {\n            try {\n                for (var _y = __values(object.reservedName), _z = _y.next(); !_z.done; _z = _y.next()) {\n                    var e = _z.value;\n                    message.reservedName.push(String(e));\n                }\n            }\n            catch (e_40_1) { e_40 = { error: e_40_1 }; }\n            finally {\n                try {\n                    if (_z && !_z.done && (_h = _y.return)) _h.call(_y);\n                }\n                finally { if (e_40) throw e_40.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        if (message.field) {\n            obj.field = message.field.map(function (e) {\n                return e ? FieldDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.field = [];\n        }\n        if (message.extension) {\n            obj.extension = message.extension.map(function (e) {\n                return e ? FieldDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.extension = [];\n        }\n        if (message.nestedType) {\n            obj.nestedType = message.nestedType.map(function (e) {\n                return e ? DescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.nestedType = [];\n        }\n        if (message.enumType) {\n            obj.enumType = message.enumType.map(function (e) {\n                return e ? EnumDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.enumType = [];\n        }\n        if (message.extensionRange) {\n            obj.extensionRange = message.extensionRange.map(function (e) {\n                return e ? DescriptorProto_ExtensionRange.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.extensionRange = [];\n        }\n        if (message.oneofDecl) {\n            obj.oneofDecl = message.oneofDecl.map(function (e) {\n                return e ? OneofDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.oneofDecl = [];\n        }\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? MessageOptions.toJSON(message.options)\n                : undefined);\n        if (message.reservedRange) {\n            obj.reservedRange = message.reservedRange.map(function (e) {\n                return e ? DescriptorProto_ReservedRange.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.reservedRange = [];\n        }\n        if (message.reservedName) {\n            obj.reservedName = message.reservedName.map(function (e) { return e; });\n        }\n        else {\n            obj.reservedName = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_41, _a, e_42, _b, e_43, _c, e_44, _d, e_45, _e, e_46, _f, e_47, _g, e_48, _h;\n        var message = __assign({}, baseDescriptorProto);\n        message.field = [];\n        message.extension = [];\n        message.nestedType = [];\n        message.enumType = [];\n        message.extensionRange = [];\n        message.oneofDecl = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.field !== undefined && object.field !== null) {\n            try {\n                for (var _j = __values(object.field), _k = _j.next(); !_k.done; _k = _j.next()) {\n                    var e = _k.value;\n                    message.field.push(FieldDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_41_1) { e_41 = { error: e_41_1 }; }\n            finally {\n                try {\n                    if (_k && !_k.done && (_a = _j.return)) _a.call(_j);\n                }\n                finally { if (e_41) throw e_41.error; }\n            }\n        }\n        if (object.extension !== undefined && object.extension !== null) {\n            try {\n                for (var _l = __values(object.extension), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var e = _m.value;\n                    message.extension.push(FieldDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_42_1) { e_42 = { error: e_42_1 }; }\n            finally {\n                try {\n                    if (_m && !_m.done && (_b = _l.return)) _b.call(_l);\n                }\n                finally { if (e_42) throw e_42.error; }\n            }\n        }\n        if (object.nestedType !== undefined && object.nestedType !== null) {\n            try {\n                for (var _o = __values(object.nestedType), _p = _o.next(); !_p.done; _p = _o.next()) {\n                    var e = _p.value;\n                    message.nestedType.push(DescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_43_1) { e_43 = { error: e_43_1 }; }\n            finally {\n                try {\n                    if (_p && !_p.done && (_c = _o.return)) _c.call(_o);\n                }\n                finally { if (e_43) throw e_43.error; }\n            }\n        }\n        if (object.enumType !== undefined && object.enumType !== null) {\n            try {\n                for (var _q = __values(object.enumType), _r = _q.next(); !_r.done; _r = _q.next()) {\n                    var e = _r.value;\n                    message.enumType.push(EnumDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_44_1) { e_44 = { error: e_44_1 }; }\n            finally {\n                try {\n                    if (_r && !_r.done && (_d = _q.return)) _d.call(_q);\n                }\n                finally { if (e_44) throw e_44.error; }\n            }\n        }\n        if (object.extensionRange !== undefined && object.extensionRange !== null) {\n            try {\n                for (var _s = __values(object.extensionRange), _t = _s.next(); !_t.done; _t = _s.next()) {\n                    var e = _t.value;\n                    message.extensionRange.push(DescriptorProto_ExtensionRange.fromPartial(e));\n                }\n            }\n            catch (e_45_1) { e_45 = { error: e_45_1 }; }\n            finally {\n                try {\n                    if (_t && !_t.done && (_e = _s.return)) _e.call(_s);\n                }\n                finally { if (e_45) throw e_45.error; }\n            }\n        }\n        if (object.oneofDecl !== undefined && object.oneofDecl !== null) {\n            try {\n                for (var _u = __values(object.oneofDecl), _v = _u.next(); !_v.done; _v = _u.next()) {\n                    var e = _v.value;\n                    message.oneofDecl.push(OneofDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_46_1) { e_46 = { error: e_46_1 }; }\n            finally {\n                try {\n                    if (_v && !_v.done && (_f = _u.return)) _f.call(_u);\n                }\n                finally { if (e_46) throw e_46.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = MessageOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.reservedRange !== undefined && object.reservedRange !== null) {\n            try {\n                for (var _w = __values(object.reservedRange), _x = _w.next(); !_x.done; _x = _w.next()) {\n                    var e = _x.value;\n                    message.reservedRange.push(DescriptorProto_ReservedRange.fromPartial(e));\n                }\n            }\n            catch (e_47_1) { e_47 = { error: e_47_1 }; }\n            finally {\n                try {\n                    if (_x && !_x.done && (_g = _w.return)) _g.call(_w);\n                }\n                finally { if (e_47) throw e_47.error; }\n            }\n        }\n        if (object.reservedName !== undefined && object.reservedName !== null) {\n            try {\n                for (var _y = __values(object.reservedName), _z = _y.next(); !_z.done; _z = _y.next()) {\n                    var e = _z.value;\n                    message.reservedName.push(e);\n                }\n            }\n            catch (e_48_1) { e_48 = { error: e_48_1 }; }\n            finally {\n                try {\n                    if (_z && !_z.done && (_h = _y.return)) _h.call(_y);\n                }\n                finally { if (e_48) throw e_48.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseDescriptorProto_ExtensionRange = { start: 0, end: 0 };\nexport var DescriptorProto_ExtensionRange = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.start !== 0) {\n            writer.uint32(8).int32(message.start);\n        }\n        if (message.end !== 0) {\n            writer.uint32(16).int32(message.end);\n        }\n        if (message.options !== undefined) {\n            ExtensionRangeOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseDescriptorProto_ExtensionRange);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.start = reader.int32();\n                    break;\n                case 2:\n                    message.end = reader.int32();\n                    break;\n                case 3:\n                    message.options = ExtensionRangeOptions.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseDescriptorProto_ExtensionRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = Number(object.start);\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = Number(object.end);\n        }\n        else {\n            message.end = 0;\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = ExtensionRangeOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.start !== undefined && (obj.start = message.start);\n        message.end !== undefined && (obj.end = message.end);\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? ExtensionRangeOptions.toJSON(message.options)\n                : undefined);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseDescriptorProto_ExtensionRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = object.start;\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = object.end;\n        }\n        else {\n            message.end = 0;\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = ExtensionRangeOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n};\nvar baseDescriptorProto_ReservedRange = { start: 0, end: 0 };\nexport var DescriptorProto_ReservedRange = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.start !== 0) {\n            writer.uint32(8).int32(message.start);\n        }\n        if (message.end !== 0) {\n            writer.uint32(16).int32(message.end);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseDescriptorProto_ReservedRange);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.start = reader.int32();\n                    break;\n                case 2:\n                    message.end = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseDescriptorProto_ReservedRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = Number(object.start);\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = Number(object.end);\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.start !== undefined && (obj.start = message.start);\n        message.end !== undefined && (obj.end = message.end);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseDescriptorProto_ReservedRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = object.start;\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = object.end;\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n};\nvar baseExtensionRangeOptions = {};\nexport var ExtensionRangeOptions = {\n    encode: function (message, writer) {\n        var e_49, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_49_1) { e_49 = { error: e_49_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_49) throw e_49.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseExtensionRangeOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_50, _a;\n        var message = __assign({}, baseExtensionRangeOptions);\n        message.uninterpretedOption = [];\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_50_1) { e_50 = { error: e_50_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_50) throw e_50.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_51, _a;\n        var message = __assign({}, baseExtensionRangeOptions);\n        message.uninterpretedOption = [];\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_51_1) { e_51 = { error: e_51_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_51) throw e_51.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseFieldDescriptorProto = {\n    name: \"\",\n    number: 0,\n    label: 1,\n    type: 1,\n    typeName: \"\",\n    extendee: \"\",\n    defaultValue: \"\",\n    oneofIndex: 0,\n    jsonName: \"\",\n    proto3Optional: false,\n};\nexport var FieldDescriptorProto = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.number !== 0) {\n            writer.uint32(24).int32(message.number);\n        }\n        if (message.label !== 1) {\n            writer.uint32(32).int32(message.label);\n        }\n        if (message.type !== 1) {\n            writer.uint32(40).int32(message.type);\n        }\n        if (message.typeName !== \"\") {\n            writer.uint32(50).string(message.typeName);\n        }\n        if (message.extendee !== \"\") {\n            writer.uint32(18).string(message.extendee);\n        }\n        if (message.defaultValue !== \"\") {\n            writer.uint32(58).string(message.defaultValue);\n        }\n        if (message.oneofIndex !== 0) {\n            writer.uint32(72).int32(message.oneofIndex);\n        }\n        if (message.jsonName !== \"\") {\n            writer.uint32(82).string(message.jsonName);\n        }\n        if (message.options !== undefined) {\n            FieldOptions.encode(message.options, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.proto3Optional === true) {\n            writer.uint32(136).bool(message.proto3Optional);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseFieldDescriptorProto);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.number = reader.int32();\n                    break;\n                case 4:\n                    message.label = reader.int32();\n                    break;\n                case 5:\n                    message.type = reader.int32();\n                    break;\n                case 6:\n                    message.typeName = reader.string();\n                    break;\n                case 2:\n                    message.extendee = reader.string();\n                    break;\n                case 7:\n                    message.defaultValue = reader.string();\n                    break;\n                case 9:\n                    message.oneofIndex = reader.int32();\n                    break;\n                case 10:\n                    message.jsonName = reader.string();\n                    break;\n                case 8:\n                    message.options = FieldOptions.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.proto3Optional = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseFieldDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.number !== undefined && object.number !== null) {\n            message.number = Number(object.number);\n        }\n        else {\n            message.number = 0;\n        }\n        if (object.label !== undefined && object.label !== null) {\n            message.label = fieldDescriptorProto_LabelFromJSON(object.label);\n        }\n        else {\n            message.label = 1;\n        }\n        if (object.type !== undefined && object.type !== null) {\n            message.type = fieldDescriptorProto_TypeFromJSON(object.type);\n        }\n        else {\n            message.type = 1;\n        }\n        if (object.typeName !== undefined && object.typeName !== null) {\n            message.typeName = String(object.typeName);\n        }\n        else {\n            message.typeName = \"\";\n        }\n        if (object.extendee !== undefined && object.extendee !== null) {\n            message.extendee = String(object.extendee);\n        }\n        else {\n            message.extendee = \"\";\n        }\n        if (object.defaultValue !== undefined && object.defaultValue !== null) {\n            message.defaultValue = String(object.defaultValue);\n        }\n        else {\n            message.defaultValue = \"\";\n        }\n        if (object.oneofIndex !== undefined && object.oneofIndex !== null) {\n            message.oneofIndex = Number(object.oneofIndex);\n        }\n        else {\n            message.oneofIndex = 0;\n        }\n        if (object.jsonName !== undefined && object.jsonName !== null) {\n            message.jsonName = String(object.jsonName);\n        }\n        else {\n            message.jsonName = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = FieldOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.proto3Optional !== undefined && object.proto3Optional !== null) {\n            message.proto3Optional = Boolean(object.proto3Optional);\n        }\n        else {\n            message.proto3Optional = false;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.number !== undefined && (obj.number = message.number);\n        message.label !== undefined &&\n            (obj.label = fieldDescriptorProto_LabelToJSON(message.label));\n        message.type !== undefined &&\n            (obj.type = fieldDescriptorProto_TypeToJSON(message.type));\n        message.typeName !== undefined && (obj.typeName = message.typeName);\n        message.extendee !== undefined && (obj.extendee = message.extendee);\n        message.defaultValue !== undefined &&\n            (obj.defaultValue = message.defaultValue);\n        message.oneofIndex !== undefined && (obj.oneofIndex = message.oneofIndex);\n        message.jsonName !== undefined && (obj.jsonName = message.jsonName);\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? FieldOptions.toJSON(message.options)\n                : undefined);\n        message.proto3Optional !== undefined &&\n            (obj.proto3Optional = message.proto3Optional);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseFieldDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.number !== undefined && object.number !== null) {\n            message.number = object.number;\n        }\n        else {\n            message.number = 0;\n        }\n        if (object.label !== undefined && object.label !== null) {\n            message.label = object.label;\n        }\n        else {\n            message.label = 1;\n        }\n        if (object.type !== undefined && object.type !== null) {\n            message.type = object.type;\n        }\n        else {\n            message.type = 1;\n        }\n        if (object.typeName !== undefined && object.typeName !== null) {\n            message.typeName = object.typeName;\n        }\n        else {\n            message.typeName = \"\";\n        }\n        if (object.extendee !== undefined && object.extendee !== null) {\n            message.extendee = object.extendee;\n        }\n        else {\n            message.extendee = \"\";\n        }\n        if (object.defaultValue !== undefined && object.defaultValue !== null) {\n            message.defaultValue = object.defaultValue;\n        }\n        else {\n            message.defaultValue = \"\";\n        }\n        if (object.oneofIndex !== undefined && object.oneofIndex !== null) {\n            message.oneofIndex = object.oneofIndex;\n        }\n        else {\n            message.oneofIndex = 0;\n        }\n        if (object.jsonName !== undefined && object.jsonName !== null) {\n            message.jsonName = object.jsonName;\n        }\n        else {\n            message.jsonName = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = FieldOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.proto3Optional !== undefined && object.proto3Optional !== null) {\n            message.proto3Optional = object.proto3Optional;\n        }\n        else {\n            message.proto3Optional = false;\n        }\n        return message;\n    },\n};\nvar baseOneofDescriptorProto = { name: \"\" };\nexport var OneofDescriptorProto = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.options !== undefined) {\n            OneofOptions.encode(message.options, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseOneofDescriptorProto);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.options = OneofOptions.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseOneofDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = OneofOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? OneofOptions.toJSON(message.options)\n                : undefined);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseOneofDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = OneofOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n};\nvar baseEnumDescriptorProto = { name: \"\", reservedName: \"\" };\nexport var EnumDescriptorProto = {\n    encode: function (message, writer) {\n        var e_52, _a, e_53, _b, e_54, _c;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        try {\n            for (var _d = __values(message.value), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var v = _e.value;\n                EnumValueDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n            }\n        }\n        catch (e_52_1) { e_52 = { error: e_52_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n            }\n            finally { if (e_52) throw e_52.error; }\n        }\n        if (message.options !== undefined) {\n            EnumOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n        }\n        try {\n            for (var _f = __values(message.reservedRange), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var v = _g.value;\n                EnumDescriptorProto_EnumReservedRange.encode(v, writer.uint32(34).fork()).ldelim();\n            }\n        }\n        catch (e_53_1) { e_53 = { error: e_53_1 }; }\n        finally {\n            try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n            }\n            finally { if (e_53) throw e_53.error; }\n        }\n        try {\n            for (var _h = __values(message.reservedName), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var v = _j.value;\n                writer.uint32(42).string(v);\n            }\n        }\n        catch (e_54_1) { e_54 = { error: e_54_1 }; }\n        finally {\n            try {\n                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n            }\n            finally { if (e_54) throw e_54.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseEnumDescriptorProto);\n        message.value = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.value.push(EnumValueDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.options = EnumOptions.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.reservedName.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_55, _a, e_56, _b, e_57, _c;\n        var message = __assign({}, baseEnumDescriptorProto);\n        message.value = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.value !== undefined && object.value !== null) {\n            try {\n                for (var _d = __values(object.value), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var e = _e.value;\n                    message.value.push(EnumValueDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_55_1) { e_55 = { error: e_55_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_55) throw e_55.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = EnumOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.reservedRange !== undefined && object.reservedRange !== null) {\n            try {\n                for (var _f = __values(object.reservedRange), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var e = _g.value;\n                    message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.fromJSON(e));\n                }\n            }\n            catch (e_56_1) { e_56 = { error: e_56_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_56) throw e_56.error; }\n            }\n        }\n        if (object.reservedName !== undefined && object.reservedName !== null) {\n            try {\n                for (var _h = __values(object.reservedName), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.reservedName.push(String(e));\n                }\n            }\n            catch (e_57_1) { e_57 = { error: e_57_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                }\n                finally { if (e_57) throw e_57.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        if (message.value) {\n            obj.value = message.value.map(function (e) {\n                return e ? EnumValueDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.value = [];\n        }\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? EnumOptions.toJSON(message.options)\n                : undefined);\n        if (message.reservedRange) {\n            obj.reservedRange = message.reservedRange.map(function (e) {\n                return e ? EnumDescriptorProto_EnumReservedRange.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.reservedRange = [];\n        }\n        if (message.reservedName) {\n            obj.reservedName = message.reservedName.map(function (e) { return e; });\n        }\n        else {\n            obj.reservedName = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_58, _a, e_59, _b, e_60, _c;\n        var message = __assign({}, baseEnumDescriptorProto);\n        message.value = [];\n        message.reservedRange = [];\n        message.reservedName = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.value !== undefined && object.value !== null) {\n            try {\n                for (var _d = __values(object.value), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var e = _e.value;\n                    message.value.push(EnumValueDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_58_1) { e_58 = { error: e_58_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_58) throw e_58.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = EnumOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.reservedRange !== undefined && object.reservedRange !== null) {\n            try {\n                for (var _f = __values(object.reservedRange), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var e = _g.value;\n                    message.reservedRange.push(EnumDescriptorProto_EnumReservedRange.fromPartial(e));\n                }\n            }\n            catch (e_59_1) { e_59 = { error: e_59_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_59) throw e_59.error; }\n            }\n        }\n        if (object.reservedName !== undefined && object.reservedName !== null) {\n            try {\n                for (var _h = __values(object.reservedName), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.reservedName.push(e);\n                }\n            }\n            catch (e_60_1) { e_60 = { error: e_60_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                }\n                finally { if (e_60) throw e_60.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseEnumDescriptorProto_EnumReservedRange = { start: 0, end: 0 };\nexport var EnumDescriptorProto_EnumReservedRange = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.start !== 0) {\n            writer.uint32(8).int32(message.start);\n        }\n        if (message.end !== 0) {\n            writer.uint32(16).int32(message.end);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseEnumDescriptorProto_EnumReservedRange);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.start = reader.int32();\n                    break;\n                case 2:\n                    message.end = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseEnumDescriptorProto_EnumReservedRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = Number(object.start);\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = Number(object.end);\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.start !== undefined && (obj.start = message.start);\n        message.end !== undefined && (obj.end = message.end);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseEnumDescriptorProto_EnumReservedRange);\n        if (object.start !== undefined && object.start !== null) {\n            message.start = object.start;\n        }\n        else {\n            message.start = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = object.end;\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n};\nvar baseEnumValueDescriptorProto = { name: \"\", number: 0 };\nexport var EnumValueDescriptorProto = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.number !== 0) {\n            writer.uint32(16).int32(message.number);\n        }\n        if (message.options !== undefined) {\n            EnumValueOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseEnumValueDescriptorProto);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.number = reader.int32();\n                    break;\n                case 3:\n                    message.options = EnumValueOptions.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseEnumValueDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.number !== undefined && object.number !== null) {\n            message.number = Number(object.number);\n        }\n        else {\n            message.number = 0;\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = EnumValueOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.number !== undefined && (obj.number = message.number);\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? EnumValueOptions.toJSON(message.options)\n                : undefined);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseEnumValueDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.number !== undefined && object.number !== null) {\n            message.number = object.number;\n        }\n        else {\n            message.number = 0;\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = EnumValueOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n};\nvar baseServiceDescriptorProto = { name: \"\" };\nexport var ServiceDescriptorProto = {\n    encode: function (message, writer) {\n        var e_61, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        try {\n            for (var _b = __values(message.method), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                MethodDescriptorProto.encode(v, writer.uint32(18).fork()).ldelim();\n            }\n        }\n        catch (e_61_1) { e_61 = { error: e_61_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_61) throw e_61.error; }\n        }\n        if (message.options !== undefined) {\n            ServiceOptions.encode(message.options, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseServiceDescriptorProto);\n        message.method = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.method.push(MethodDescriptorProto.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.options = ServiceOptions.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_62, _a;\n        var message = __assign({}, baseServiceDescriptorProto);\n        message.method = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.method !== undefined && object.method !== null) {\n            try {\n                for (var _b = __values(object.method), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.method.push(MethodDescriptorProto.fromJSON(e));\n                }\n            }\n            catch (e_62_1) { e_62 = { error: e_62_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_62) throw e_62.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = ServiceOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        if (message.method) {\n            obj.method = message.method.map(function (e) {\n                return e ? MethodDescriptorProto.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.method = [];\n        }\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? ServiceOptions.toJSON(message.options)\n                : undefined);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_63, _a;\n        var message = __assign({}, baseServiceDescriptorProto);\n        message.method = [];\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.method !== undefined && object.method !== null) {\n            try {\n                for (var _b = __values(object.method), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.method.push(MethodDescriptorProto.fromPartial(e));\n                }\n            }\n            catch (e_63_1) { e_63 = { error: e_63_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_63) throw e_63.error; }\n            }\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = ServiceOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        return message;\n    },\n};\nvar baseMethodDescriptorProto = {\n    name: \"\",\n    inputType: \"\",\n    outputType: \"\",\n    clientStreaming: false,\n    serverStreaming: false,\n};\nexport var MethodDescriptorProto = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.inputType !== \"\") {\n            writer.uint32(18).string(message.inputType);\n        }\n        if (message.outputType !== \"\") {\n            writer.uint32(26).string(message.outputType);\n        }\n        if (message.options !== undefined) {\n            MethodOptions.encode(message.options, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.clientStreaming === true) {\n            writer.uint32(40).bool(message.clientStreaming);\n        }\n        if (message.serverStreaming === true) {\n            writer.uint32(48).bool(message.serverStreaming);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseMethodDescriptorProto);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.inputType = reader.string();\n                    break;\n                case 3:\n                    message.outputType = reader.string();\n                    break;\n                case 4:\n                    message.options = MethodOptions.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.clientStreaming = reader.bool();\n                    break;\n                case 6:\n                    message.serverStreaming = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseMethodDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = String(object.name);\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.inputType !== undefined && object.inputType !== null) {\n            message.inputType = String(object.inputType);\n        }\n        else {\n            message.inputType = \"\";\n        }\n        if (object.outputType !== undefined && object.outputType !== null) {\n            message.outputType = String(object.outputType);\n        }\n        else {\n            message.outputType = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = MethodOptions.fromJSON(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.clientStreaming !== undefined &&\n            object.clientStreaming !== null) {\n            message.clientStreaming = Boolean(object.clientStreaming);\n        }\n        else {\n            message.clientStreaming = false;\n        }\n        if (object.serverStreaming !== undefined &&\n            object.serverStreaming !== null) {\n            message.serverStreaming = Boolean(object.serverStreaming);\n        }\n        else {\n            message.serverStreaming = false;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.inputType !== undefined && (obj.inputType = message.inputType);\n        message.outputType !== undefined && (obj.outputType = message.outputType);\n        message.options !== undefined &&\n            (obj.options = message.options\n                ? MethodOptions.toJSON(message.options)\n                : undefined);\n        message.clientStreaming !== undefined &&\n            (obj.clientStreaming = message.clientStreaming);\n        message.serverStreaming !== undefined &&\n            (obj.serverStreaming = message.serverStreaming);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseMethodDescriptorProto);\n        if (object.name !== undefined && object.name !== null) {\n            message.name = object.name;\n        }\n        else {\n            message.name = \"\";\n        }\n        if (object.inputType !== undefined && object.inputType !== null) {\n            message.inputType = object.inputType;\n        }\n        else {\n            message.inputType = \"\";\n        }\n        if (object.outputType !== undefined && object.outputType !== null) {\n            message.outputType = object.outputType;\n        }\n        else {\n            message.outputType = \"\";\n        }\n        if (object.options !== undefined && object.options !== null) {\n            message.options = MethodOptions.fromPartial(object.options);\n        }\n        else {\n            message.options = undefined;\n        }\n        if (object.clientStreaming !== undefined &&\n            object.clientStreaming !== null) {\n            message.clientStreaming = object.clientStreaming;\n        }\n        else {\n            message.clientStreaming = false;\n        }\n        if (object.serverStreaming !== undefined &&\n            object.serverStreaming !== null) {\n            message.serverStreaming = object.serverStreaming;\n        }\n        else {\n            message.serverStreaming = false;\n        }\n        return message;\n    },\n};\nvar baseFileOptions = {\n    javaPackage: \"\",\n    javaOuterClassname: \"\",\n    javaMultipleFiles: false,\n    javaGenerateEqualsAndHash: false,\n    javaStringCheckUtf8: false,\n    optimizeFor: 1,\n    goPackage: \"\",\n    ccGenericServices: false,\n    javaGenericServices: false,\n    pyGenericServices: false,\n    phpGenericServices: false,\n    deprecated: false,\n    ccEnableArenas: false,\n    objcClassPrefix: \"\",\n    csharpNamespace: \"\",\n    swiftPrefix: \"\",\n    phpClassPrefix: \"\",\n    phpNamespace: \"\",\n    phpMetadataNamespace: \"\",\n    rubyPackage: \"\",\n};\nexport var FileOptions = {\n    encode: function (message, writer) {\n        var e_64, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.javaPackage !== \"\") {\n            writer.uint32(10).string(message.javaPackage);\n        }\n        if (message.javaOuterClassname !== \"\") {\n            writer.uint32(66).string(message.javaOuterClassname);\n        }\n        if (message.javaMultipleFiles === true) {\n            writer.uint32(80).bool(message.javaMultipleFiles);\n        }\n        if (message.javaGenerateEqualsAndHash === true) {\n            writer.uint32(160).bool(message.javaGenerateEqualsAndHash);\n        }\n        if (message.javaStringCheckUtf8 === true) {\n            writer.uint32(216).bool(message.javaStringCheckUtf8);\n        }\n        if (message.optimizeFor !== 1) {\n            writer.uint32(72).int32(message.optimizeFor);\n        }\n        if (message.goPackage !== \"\") {\n            writer.uint32(90).string(message.goPackage);\n        }\n        if (message.ccGenericServices === true) {\n            writer.uint32(128).bool(message.ccGenericServices);\n        }\n        if (message.javaGenericServices === true) {\n            writer.uint32(136).bool(message.javaGenericServices);\n        }\n        if (message.pyGenericServices === true) {\n            writer.uint32(144).bool(message.pyGenericServices);\n        }\n        if (message.phpGenericServices === true) {\n            writer.uint32(336).bool(message.phpGenericServices);\n        }\n        if (message.deprecated === true) {\n            writer.uint32(184).bool(message.deprecated);\n        }\n        if (message.ccEnableArenas === true) {\n            writer.uint32(248).bool(message.ccEnableArenas);\n        }\n        if (message.objcClassPrefix !== \"\") {\n            writer.uint32(290).string(message.objcClassPrefix);\n        }\n        if (message.csharpNamespace !== \"\") {\n            writer.uint32(298).string(message.csharpNamespace);\n        }\n        if (message.swiftPrefix !== \"\") {\n            writer.uint32(314).string(message.swiftPrefix);\n        }\n        if (message.phpClassPrefix !== \"\") {\n            writer.uint32(322).string(message.phpClassPrefix);\n        }\n        if (message.phpNamespace !== \"\") {\n            writer.uint32(330).string(message.phpNamespace);\n        }\n        if (message.phpMetadataNamespace !== \"\") {\n            writer.uint32(354).string(message.phpMetadataNamespace);\n        }\n        if (message.rubyPackage !== \"\") {\n            writer.uint32(362).string(message.rubyPackage);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_64_1) { e_64 = { error: e_64_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_64) throw e_64.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseFileOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.javaPackage = reader.string();\n                    break;\n                case 8:\n                    message.javaOuterClassname = reader.string();\n                    break;\n                case 10:\n                    message.javaMultipleFiles = reader.bool();\n                    break;\n                case 20:\n                    message.javaGenerateEqualsAndHash = reader.bool();\n                    break;\n                case 27:\n                    message.javaStringCheckUtf8 = reader.bool();\n                    break;\n                case 9:\n                    message.optimizeFor = reader.int32();\n                    break;\n                case 11:\n                    message.goPackage = reader.string();\n                    break;\n                case 16:\n                    message.ccGenericServices = reader.bool();\n                    break;\n                case 17:\n                    message.javaGenericServices = reader.bool();\n                    break;\n                case 18:\n                    message.pyGenericServices = reader.bool();\n                    break;\n                case 42:\n                    message.phpGenericServices = reader.bool();\n                    break;\n                case 23:\n                    message.deprecated = reader.bool();\n                    break;\n                case 31:\n                    message.ccEnableArenas = reader.bool();\n                    break;\n                case 36:\n                    message.objcClassPrefix = reader.string();\n                    break;\n                case 37:\n                    message.csharpNamespace = reader.string();\n                    break;\n                case 39:\n                    message.swiftPrefix = reader.string();\n                    break;\n                case 40:\n                    message.phpClassPrefix = reader.string();\n                    break;\n                case 41:\n                    message.phpNamespace = reader.string();\n                    break;\n                case 44:\n                    message.phpMetadataNamespace = reader.string();\n                    break;\n                case 45:\n                    message.rubyPackage = reader.string();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_65, _a;\n        var message = __assign({}, baseFileOptions);\n        message.uninterpretedOption = [];\n        if (object.javaPackage !== undefined && object.javaPackage !== null) {\n            message.javaPackage = String(object.javaPackage);\n        }\n        else {\n            message.javaPackage = \"\";\n        }\n        if (object.javaOuterClassname !== undefined &&\n            object.javaOuterClassname !== null) {\n            message.javaOuterClassname = String(object.javaOuterClassname);\n        }\n        else {\n            message.javaOuterClassname = \"\";\n        }\n        if (object.javaMultipleFiles !== undefined &&\n            object.javaMultipleFiles !== null) {\n            message.javaMultipleFiles = Boolean(object.javaMultipleFiles);\n        }\n        else {\n            message.javaMultipleFiles = false;\n        }\n        if (object.javaGenerateEqualsAndHash !== undefined &&\n            object.javaGenerateEqualsAndHash !== null) {\n            message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);\n        }\n        else {\n            message.javaGenerateEqualsAndHash = false;\n        }\n        if (object.javaStringCheckUtf8 !== undefined &&\n            object.javaStringCheckUtf8 !== null) {\n            message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);\n        }\n        else {\n            message.javaStringCheckUtf8 = false;\n        }\n        if (object.optimizeFor !== undefined && object.optimizeFor !== null) {\n            message.optimizeFor = fileOptions_OptimizeModeFromJSON(object.optimizeFor);\n        }\n        else {\n            message.optimizeFor = 1;\n        }\n        if (object.goPackage !== undefined && object.goPackage !== null) {\n            message.goPackage = String(object.goPackage);\n        }\n        else {\n            message.goPackage = \"\";\n        }\n        if (object.ccGenericServices !== undefined &&\n            object.ccGenericServices !== null) {\n            message.ccGenericServices = Boolean(object.ccGenericServices);\n        }\n        else {\n            message.ccGenericServices = false;\n        }\n        if (object.javaGenericServices !== undefined &&\n            object.javaGenericServices !== null) {\n            message.javaGenericServices = Boolean(object.javaGenericServices);\n        }\n        else {\n            message.javaGenericServices = false;\n        }\n        if (object.pyGenericServices !== undefined &&\n            object.pyGenericServices !== null) {\n            message.pyGenericServices = Boolean(object.pyGenericServices);\n        }\n        else {\n            message.pyGenericServices = false;\n        }\n        if (object.phpGenericServices !== undefined &&\n            object.phpGenericServices !== null) {\n            message.phpGenericServices = Boolean(object.phpGenericServices);\n        }\n        else {\n            message.phpGenericServices = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.ccEnableArenas !== undefined && object.ccEnableArenas !== null) {\n            message.ccEnableArenas = Boolean(object.ccEnableArenas);\n        }\n        else {\n            message.ccEnableArenas = false;\n        }\n        if (object.objcClassPrefix !== undefined &&\n            object.objcClassPrefix !== null) {\n            message.objcClassPrefix = String(object.objcClassPrefix);\n        }\n        else {\n            message.objcClassPrefix = \"\";\n        }\n        if (object.csharpNamespace !== undefined &&\n            object.csharpNamespace !== null) {\n            message.csharpNamespace = String(object.csharpNamespace);\n        }\n        else {\n            message.csharpNamespace = \"\";\n        }\n        if (object.swiftPrefix !== undefined && object.swiftPrefix !== null) {\n            message.swiftPrefix = String(object.swiftPrefix);\n        }\n        else {\n            message.swiftPrefix = \"\";\n        }\n        if (object.phpClassPrefix !== undefined && object.phpClassPrefix !== null) {\n            message.phpClassPrefix = String(object.phpClassPrefix);\n        }\n        else {\n            message.phpClassPrefix = \"\";\n        }\n        if (object.phpNamespace !== undefined && object.phpNamespace !== null) {\n            message.phpNamespace = String(object.phpNamespace);\n        }\n        else {\n            message.phpNamespace = \"\";\n        }\n        if (object.phpMetadataNamespace !== undefined &&\n            object.phpMetadataNamespace !== null) {\n            message.phpMetadataNamespace = String(object.phpMetadataNamespace);\n        }\n        else {\n            message.phpMetadataNamespace = \"\";\n        }\n        if (object.rubyPackage !== undefined && object.rubyPackage !== null) {\n            message.rubyPackage = String(object.rubyPackage);\n        }\n        else {\n            message.rubyPackage = \"\";\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_65_1) { e_65 = { error: e_65_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_65) throw e_65.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.javaPackage !== undefined &&\n            (obj.javaPackage = message.javaPackage);\n        message.javaOuterClassname !== undefined &&\n            (obj.javaOuterClassname = message.javaOuterClassname);\n        message.javaMultipleFiles !== undefined &&\n            (obj.javaMultipleFiles = message.javaMultipleFiles);\n        message.javaGenerateEqualsAndHash !== undefined &&\n            (obj.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash);\n        message.javaStringCheckUtf8 !== undefined &&\n            (obj.javaStringCheckUtf8 = message.javaStringCheckUtf8);\n        message.optimizeFor !== undefined &&\n            (obj.optimizeFor = fileOptions_OptimizeModeToJSON(message.optimizeFor));\n        message.goPackage !== undefined && (obj.goPackage = message.goPackage);\n        message.ccGenericServices !== undefined &&\n            (obj.ccGenericServices = message.ccGenericServices);\n        message.javaGenericServices !== undefined &&\n            (obj.javaGenericServices = message.javaGenericServices);\n        message.pyGenericServices !== undefined &&\n            (obj.pyGenericServices = message.pyGenericServices);\n        message.phpGenericServices !== undefined &&\n            (obj.phpGenericServices = message.phpGenericServices);\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        message.ccEnableArenas !== undefined &&\n            (obj.ccEnableArenas = message.ccEnableArenas);\n        message.objcClassPrefix !== undefined &&\n            (obj.objcClassPrefix = message.objcClassPrefix);\n        message.csharpNamespace !== undefined &&\n            (obj.csharpNamespace = message.csharpNamespace);\n        message.swiftPrefix !== undefined &&\n            (obj.swiftPrefix = message.swiftPrefix);\n        message.phpClassPrefix !== undefined &&\n            (obj.phpClassPrefix = message.phpClassPrefix);\n        message.phpNamespace !== undefined &&\n            (obj.phpNamespace = message.phpNamespace);\n        message.phpMetadataNamespace !== undefined &&\n            (obj.phpMetadataNamespace = message.phpMetadataNamespace);\n        message.rubyPackage !== undefined &&\n            (obj.rubyPackage = message.rubyPackage);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_66, _a;\n        var message = __assign({}, baseFileOptions);\n        message.uninterpretedOption = [];\n        if (object.javaPackage !== undefined && object.javaPackage !== null) {\n            message.javaPackage = object.javaPackage;\n        }\n        else {\n            message.javaPackage = \"\";\n        }\n        if (object.javaOuterClassname !== undefined &&\n            object.javaOuterClassname !== null) {\n            message.javaOuterClassname = object.javaOuterClassname;\n        }\n        else {\n            message.javaOuterClassname = \"\";\n        }\n        if (object.javaMultipleFiles !== undefined &&\n            object.javaMultipleFiles !== null) {\n            message.javaMultipleFiles = object.javaMultipleFiles;\n        }\n        else {\n            message.javaMultipleFiles = false;\n        }\n        if (object.javaGenerateEqualsAndHash !== undefined &&\n            object.javaGenerateEqualsAndHash !== null) {\n            message.javaGenerateEqualsAndHash = object.javaGenerateEqualsAndHash;\n        }\n        else {\n            message.javaGenerateEqualsAndHash = false;\n        }\n        if (object.javaStringCheckUtf8 !== undefined &&\n            object.javaStringCheckUtf8 !== null) {\n            message.javaStringCheckUtf8 = object.javaStringCheckUtf8;\n        }\n        else {\n            message.javaStringCheckUtf8 = false;\n        }\n        if (object.optimizeFor !== undefined && object.optimizeFor !== null) {\n            message.optimizeFor = object.optimizeFor;\n        }\n        else {\n            message.optimizeFor = 1;\n        }\n        if (object.goPackage !== undefined && object.goPackage !== null) {\n            message.goPackage = object.goPackage;\n        }\n        else {\n            message.goPackage = \"\";\n        }\n        if (object.ccGenericServices !== undefined &&\n            object.ccGenericServices !== null) {\n            message.ccGenericServices = object.ccGenericServices;\n        }\n        else {\n            message.ccGenericServices = false;\n        }\n        if (object.javaGenericServices !== undefined &&\n            object.javaGenericServices !== null) {\n            message.javaGenericServices = object.javaGenericServices;\n        }\n        else {\n            message.javaGenericServices = false;\n        }\n        if (object.pyGenericServices !== undefined &&\n            object.pyGenericServices !== null) {\n            message.pyGenericServices = object.pyGenericServices;\n        }\n        else {\n            message.pyGenericServices = false;\n        }\n        if (object.phpGenericServices !== undefined &&\n            object.phpGenericServices !== null) {\n            message.phpGenericServices = object.phpGenericServices;\n        }\n        else {\n            message.phpGenericServices = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.ccEnableArenas !== undefined && object.ccEnableArenas !== null) {\n            message.ccEnableArenas = object.ccEnableArenas;\n        }\n        else {\n            message.ccEnableArenas = false;\n        }\n        if (object.objcClassPrefix !== undefined &&\n            object.objcClassPrefix !== null) {\n            message.objcClassPrefix = object.objcClassPrefix;\n        }\n        else {\n            message.objcClassPrefix = \"\";\n        }\n        if (object.csharpNamespace !== undefined &&\n            object.csharpNamespace !== null) {\n            message.csharpNamespace = object.csharpNamespace;\n        }\n        else {\n            message.csharpNamespace = \"\";\n        }\n        if (object.swiftPrefix !== undefined && object.swiftPrefix !== null) {\n            message.swiftPrefix = object.swiftPrefix;\n        }\n        else {\n            message.swiftPrefix = \"\";\n        }\n        if (object.phpClassPrefix !== undefined && object.phpClassPrefix !== null) {\n            message.phpClassPrefix = object.phpClassPrefix;\n        }\n        else {\n            message.phpClassPrefix = \"\";\n        }\n        if (object.phpNamespace !== undefined && object.phpNamespace !== null) {\n            message.phpNamespace = object.phpNamespace;\n        }\n        else {\n            message.phpNamespace = \"\";\n        }\n        if (object.phpMetadataNamespace !== undefined &&\n            object.phpMetadataNamespace !== null) {\n            message.phpMetadataNamespace = object.phpMetadataNamespace;\n        }\n        else {\n            message.phpMetadataNamespace = \"\";\n        }\n        if (object.rubyPackage !== undefined && object.rubyPackage !== null) {\n            message.rubyPackage = object.rubyPackage;\n        }\n        else {\n            message.rubyPackage = \"\";\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_66_1) { e_66 = { error: e_66_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_66) throw e_66.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseMessageOptions = {\n    messageSetWireFormat: false,\n    noStandardDescriptorAccessor: false,\n    deprecated: false,\n    mapEntry: false,\n};\nexport var MessageOptions = {\n    encode: function (message, writer) {\n        var e_67, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.messageSetWireFormat === true) {\n            writer.uint32(8).bool(message.messageSetWireFormat);\n        }\n        if (message.noStandardDescriptorAccessor === true) {\n            writer.uint32(16).bool(message.noStandardDescriptorAccessor);\n        }\n        if (message.deprecated === true) {\n            writer.uint32(24).bool(message.deprecated);\n        }\n        if (message.mapEntry === true) {\n            writer.uint32(56).bool(message.mapEntry);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_67_1) { e_67 = { error: e_67_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_67) throw e_67.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseMessageOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageSetWireFormat = reader.bool();\n                    break;\n                case 2:\n                    message.noStandardDescriptorAccessor = reader.bool();\n                    break;\n                case 3:\n                    message.deprecated = reader.bool();\n                    break;\n                case 7:\n                    message.mapEntry = reader.bool();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_68, _a;\n        var message = __assign({}, baseMessageOptions);\n        message.uninterpretedOption = [];\n        if (object.messageSetWireFormat !== undefined &&\n            object.messageSetWireFormat !== null) {\n            message.messageSetWireFormat = Boolean(object.messageSetWireFormat);\n        }\n        else {\n            message.messageSetWireFormat = false;\n        }\n        if (object.noStandardDescriptorAccessor !== undefined &&\n            object.noStandardDescriptorAccessor !== null) {\n            message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);\n        }\n        else {\n            message.noStandardDescriptorAccessor = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.mapEntry !== undefined && object.mapEntry !== null) {\n            message.mapEntry = Boolean(object.mapEntry);\n        }\n        else {\n            message.mapEntry = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_68_1) { e_68 = { error: e_68_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_68) throw e_68.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.messageSetWireFormat !== undefined &&\n            (obj.messageSetWireFormat = message.messageSetWireFormat);\n        message.noStandardDescriptorAccessor !== undefined &&\n            (obj.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor);\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        message.mapEntry !== undefined && (obj.mapEntry = message.mapEntry);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_69, _a;\n        var message = __assign({}, baseMessageOptions);\n        message.uninterpretedOption = [];\n        if (object.messageSetWireFormat !== undefined &&\n            object.messageSetWireFormat !== null) {\n            message.messageSetWireFormat = object.messageSetWireFormat;\n        }\n        else {\n            message.messageSetWireFormat = false;\n        }\n        if (object.noStandardDescriptorAccessor !== undefined &&\n            object.noStandardDescriptorAccessor !== null) {\n            message.noStandardDescriptorAccessor =\n                object.noStandardDescriptorAccessor;\n        }\n        else {\n            message.noStandardDescriptorAccessor = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.mapEntry !== undefined && object.mapEntry !== null) {\n            message.mapEntry = object.mapEntry;\n        }\n        else {\n            message.mapEntry = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_69_1) { e_69 = { error: e_69_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_69) throw e_69.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseFieldOptions = {\n    ctype: 0,\n    packed: false,\n    jstype: 0,\n    lazy: false,\n    deprecated: false,\n    weak: false,\n};\nexport var FieldOptions = {\n    encode: function (message, writer) {\n        var e_70, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.ctype !== 0) {\n            writer.uint32(8).int32(message.ctype);\n        }\n        if (message.packed === true) {\n            writer.uint32(16).bool(message.packed);\n        }\n        if (message.jstype !== 0) {\n            writer.uint32(48).int32(message.jstype);\n        }\n        if (message.lazy === true) {\n            writer.uint32(40).bool(message.lazy);\n        }\n        if (message.deprecated === true) {\n            writer.uint32(24).bool(message.deprecated);\n        }\n        if (message.weak === true) {\n            writer.uint32(80).bool(message.weak);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_70_1) { e_70 = { error: e_70_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_70) throw e_70.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseFieldOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ctype = reader.int32();\n                    break;\n                case 2:\n                    message.packed = reader.bool();\n                    break;\n                case 6:\n                    message.jstype = reader.int32();\n                    break;\n                case 5:\n                    message.lazy = reader.bool();\n                    break;\n                case 3:\n                    message.deprecated = reader.bool();\n                    break;\n                case 10:\n                    message.weak = reader.bool();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_71, _a;\n        var message = __assign({}, baseFieldOptions);\n        message.uninterpretedOption = [];\n        if (object.ctype !== undefined && object.ctype !== null) {\n            message.ctype = fieldOptions_CTypeFromJSON(object.ctype);\n        }\n        else {\n            message.ctype = 0;\n        }\n        if (object.packed !== undefined && object.packed !== null) {\n            message.packed = Boolean(object.packed);\n        }\n        else {\n            message.packed = false;\n        }\n        if (object.jstype !== undefined && object.jstype !== null) {\n            message.jstype = fieldOptions_JSTypeFromJSON(object.jstype);\n        }\n        else {\n            message.jstype = 0;\n        }\n        if (object.lazy !== undefined && object.lazy !== null) {\n            message.lazy = Boolean(object.lazy);\n        }\n        else {\n            message.lazy = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.weak !== undefined && object.weak !== null) {\n            message.weak = Boolean(object.weak);\n        }\n        else {\n            message.weak = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_71_1) { e_71 = { error: e_71_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_71) throw e_71.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.ctype !== undefined &&\n            (obj.ctype = fieldOptions_CTypeToJSON(message.ctype));\n        message.packed !== undefined && (obj.packed = message.packed);\n        message.jstype !== undefined &&\n            (obj.jstype = fieldOptions_JSTypeToJSON(message.jstype));\n        message.lazy !== undefined && (obj.lazy = message.lazy);\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        message.weak !== undefined && (obj.weak = message.weak);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_72, _a;\n        var message = __assign({}, baseFieldOptions);\n        message.uninterpretedOption = [];\n        if (object.ctype !== undefined && object.ctype !== null) {\n            message.ctype = object.ctype;\n        }\n        else {\n            message.ctype = 0;\n        }\n        if (object.packed !== undefined && object.packed !== null) {\n            message.packed = object.packed;\n        }\n        else {\n            message.packed = false;\n        }\n        if (object.jstype !== undefined && object.jstype !== null) {\n            message.jstype = object.jstype;\n        }\n        else {\n            message.jstype = 0;\n        }\n        if (object.lazy !== undefined && object.lazy !== null) {\n            message.lazy = object.lazy;\n        }\n        else {\n            message.lazy = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.weak !== undefined && object.weak !== null) {\n            message.weak = object.weak;\n        }\n        else {\n            message.weak = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_72_1) { e_72 = { error: e_72_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_72) throw e_72.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseOneofOptions = {};\nexport var OneofOptions = {\n    encode: function (message, writer) {\n        var e_73, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_73_1) { e_73 = { error: e_73_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_73) throw e_73.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseOneofOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_74, _a;\n        var message = __assign({}, baseOneofOptions);\n        message.uninterpretedOption = [];\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_74_1) { e_74 = { error: e_74_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_74) throw e_74.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_75, _a;\n        var message = __assign({}, baseOneofOptions);\n        message.uninterpretedOption = [];\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_75_1) { e_75 = { error: e_75_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_75) throw e_75.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseEnumOptions = { allowAlias: false, deprecated: false };\nexport var EnumOptions = {\n    encode: function (message, writer) {\n        var e_76, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.allowAlias === true) {\n            writer.uint32(16).bool(message.allowAlias);\n        }\n        if (message.deprecated === true) {\n            writer.uint32(24).bool(message.deprecated);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_76_1) { e_76 = { error: e_76_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_76) throw e_76.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseEnumOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.allowAlias = reader.bool();\n                    break;\n                case 3:\n                    message.deprecated = reader.bool();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_77, _a;\n        var message = __assign({}, baseEnumOptions);\n        message.uninterpretedOption = [];\n        if (object.allowAlias !== undefined && object.allowAlias !== null) {\n            message.allowAlias = Boolean(object.allowAlias);\n        }\n        else {\n            message.allowAlias = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_77_1) { e_77 = { error: e_77_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_77) throw e_77.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.allowAlias !== undefined && (obj.allowAlias = message.allowAlias);\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_78, _a;\n        var message = __assign({}, baseEnumOptions);\n        message.uninterpretedOption = [];\n        if (object.allowAlias !== undefined && object.allowAlias !== null) {\n            message.allowAlias = object.allowAlias;\n        }\n        else {\n            message.allowAlias = false;\n        }\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_78_1) { e_78 = { error: e_78_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_78) throw e_78.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseEnumValueOptions = { deprecated: false };\nexport var EnumValueOptions = {\n    encode: function (message, writer) {\n        var e_79, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.deprecated === true) {\n            writer.uint32(8).bool(message.deprecated);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_79_1) { e_79 = { error: e_79_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_79) throw e_79.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseEnumValueOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.deprecated = reader.bool();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_80, _a;\n        var message = __assign({}, baseEnumValueOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_80_1) { e_80 = { error: e_80_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_80) throw e_80.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_81, _a;\n        var message = __assign({}, baseEnumValueOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_81_1) { e_81 = { error: e_81_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_81) throw e_81.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseServiceOptions = { deprecated: false };\nexport var ServiceOptions = {\n    encode: function (message, writer) {\n        var e_82, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.deprecated === true) {\n            writer.uint32(264).bool(message.deprecated);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_82_1) { e_82 = { error: e_82_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_82) throw e_82.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseServiceOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 33:\n                    message.deprecated = reader.bool();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_83, _a;\n        var message = __assign({}, baseServiceOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_83_1) { e_83 = { error: e_83_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_83) throw e_83.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_84, _a;\n        var message = __assign({}, baseServiceOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_84_1) { e_84 = { error: e_84_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_84) throw e_84.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseMethodOptions = { deprecated: false, idempotencyLevel: 0 };\nexport var MethodOptions = {\n    encode: function (message, writer) {\n        var e_85, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.deprecated === true) {\n            writer.uint32(264).bool(message.deprecated);\n        }\n        if (message.idempotencyLevel !== 0) {\n            writer.uint32(272).int32(message.idempotencyLevel);\n        }\n        try {\n            for (var _b = __values(message.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption.encode(v, writer.uint32(7994).fork()).ldelim();\n            }\n        }\n        catch (e_85_1) { e_85 = { error: e_85_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_85) throw e_85.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseMethodOptions);\n        message.uninterpretedOption = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 33:\n                    message.deprecated = reader.bool();\n                    break;\n                case 34:\n                    message.idempotencyLevel = reader.int32();\n                    break;\n                case 999:\n                    message.uninterpretedOption.push(UninterpretedOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_86, _a;\n        var message = __assign({}, baseMethodOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = Boolean(object.deprecated);\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.idempotencyLevel !== undefined &&\n            object.idempotencyLevel !== null) {\n            message.idempotencyLevel = methodOptions_IdempotencyLevelFromJSON(object.idempotencyLevel);\n        }\n        else {\n            message.idempotencyLevel = 0;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromJSON(e));\n                }\n            }\n            catch (e_86_1) { e_86 = { error: e_86_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_86) throw e_86.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.deprecated !== undefined && (obj.deprecated = message.deprecated);\n        message.idempotencyLevel !== undefined &&\n            (obj.idempotencyLevel = methodOptions_IdempotencyLevelToJSON(message.idempotencyLevel));\n        if (message.uninterpretedOption) {\n            obj.uninterpretedOption = message.uninterpretedOption.map(function (e) {\n                return e ? UninterpretedOption.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.uninterpretedOption = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_87, _a;\n        var message = __assign({}, baseMethodOptions);\n        message.uninterpretedOption = [];\n        if (object.deprecated !== undefined && object.deprecated !== null) {\n            message.deprecated = object.deprecated;\n        }\n        else {\n            message.deprecated = false;\n        }\n        if (object.idempotencyLevel !== undefined &&\n            object.idempotencyLevel !== null) {\n            message.idempotencyLevel = object.idempotencyLevel;\n        }\n        else {\n            message.idempotencyLevel = 0;\n        }\n        if (object.uninterpretedOption !== undefined &&\n            object.uninterpretedOption !== null) {\n            try {\n                for (var _b = __values(object.uninterpretedOption), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.uninterpretedOption.push(UninterpretedOption.fromPartial(e));\n                }\n            }\n            catch (e_87_1) { e_87 = { error: e_87_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_87) throw e_87.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseUninterpretedOption = {\n    identifierValue: \"\",\n    positiveIntValue: \"0\",\n    negativeIntValue: \"0\",\n    doubleValue: 0,\n    aggregateValue: \"\",\n};\nexport var UninterpretedOption = {\n    encode: function (message, writer) {\n        var e_88, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.name), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                UninterpretedOption_NamePart.encode(v, writer.uint32(18).fork()).ldelim();\n            }\n        }\n        catch (e_88_1) { e_88 = { error: e_88_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_88) throw e_88.error; }\n        }\n        if (message.identifierValue !== \"\") {\n            writer.uint32(26).string(message.identifierValue);\n        }\n        if (message.positiveIntValue !== \"0\") {\n            writer.uint32(32).uint64(message.positiveIntValue);\n        }\n        if (message.negativeIntValue !== \"0\") {\n            writer.uint32(40).int64(message.negativeIntValue);\n        }\n        if (message.doubleValue !== 0) {\n            writer.uint32(49).double(message.doubleValue);\n        }\n        if (message.stringValue.length !== 0) {\n            writer.uint32(58).bytes(message.stringValue);\n        }\n        if (message.aggregateValue !== \"\") {\n            writer.uint32(66).string(message.aggregateValue);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseUninterpretedOption);\n        message.name = [];\n        message.stringValue = new Uint8Array();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.name.push(UninterpretedOption_NamePart.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.identifierValue = reader.string();\n                    break;\n                case 4:\n                    message.positiveIntValue = longToString(reader.uint64());\n                    break;\n                case 5:\n                    message.negativeIntValue = longToString(reader.int64());\n                    break;\n                case 6:\n                    message.doubleValue = reader.double();\n                    break;\n                case 7:\n                    message.stringValue = reader.bytes();\n                    break;\n                case 8:\n                    message.aggregateValue = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_89, _a;\n        var message = __assign({}, baseUninterpretedOption);\n        message.name = [];\n        message.stringValue = new Uint8Array();\n        if (object.name !== undefined && object.name !== null) {\n            try {\n                for (var _b = __values(object.name), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.name.push(UninterpretedOption_NamePart.fromJSON(e));\n                }\n            }\n            catch (e_89_1) { e_89 = { error: e_89_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_89) throw e_89.error; }\n            }\n        }\n        if (object.identifierValue !== undefined &&\n            object.identifierValue !== null) {\n            message.identifierValue = String(object.identifierValue);\n        }\n        else {\n            message.identifierValue = \"\";\n        }\n        if (object.positiveIntValue !== undefined &&\n            object.positiveIntValue !== null) {\n            message.positiveIntValue = String(object.positiveIntValue);\n        }\n        else {\n            message.positiveIntValue = \"0\";\n        }\n        if (object.negativeIntValue !== undefined &&\n            object.negativeIntValue !== null) {\n            message.negativeIntValue = String(object.negativeIntValue);\n        }\n        else {\n            message.negativeIntValue = \"0\";\n        }\n        if (object.doubleValue !== undefined && object.doubleValue !== null) {\n            message.doubleValue = Number(object.doubleValue);\n        }\n        else {\n            message.doubleValue = 0;\n        }\n        if (object.stringValue !== undefined && object.stringValue !== null) {\n            message.stringValue = bytesFromBase64(object.stringValue);\n        }\n        if (object.aggregateValue !== undefined && object.aggregateValue !== null) {\n            message.aggregateValue = String(object.aggregateValue);\n        }\n        else {\n            message.aggregateValue = \"\";\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.name) {\n            obj.name = message.name.map(function (e) {\n                return e ? UninterpretedOption_NamePart.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.name = [];\n        }\n        message.identifierValue !== undefined &&\n            (obj.identifierValue = message.identifierValue);\n        message.positiveIntValue !== undefined &&\n            (obj.positiveIntValue = message.positiveIntValue);\n        message.negativeIntValue !== undefined &&\n            (obj.negativeIntValue = message.negativeIntValue);\n        message.doubleValue !== undefined &&\n            (obj.doubleValue = message.doubleValue);\n        message.stringValue !== undefined &&\n            (obj.stringValue = base64FromBytes(message.stringValue !== undefined\n                ? message.stringValue\n                : new Uint8Array()));\n        message.aggregateValue !== undefined &&\n            (obj.aggregateValue = message.aggregateValue);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_90, _a;\n        var message = __assign({}, baseUninterpretedOption);\n        message.name = [];\n        if (object.name !== undefined && object.name !== null) {\n            try {\n                for (var _b = __values(object.name), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.name.push(UninterpretedOption_NamePart.fromPartial(e));\n                }\n            }\n            catch (e_90_1) { e_90 = { error: e_90_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_90) throw e_90.error; }\n            }\n        }\n        if (object.identifierValue !== undefined &&\n            object.identifierValue !== null) {\n            message.identifierValue = object.identifierValue;\n        }\n        else {\n            message.identifierValue = \"\";\n        }\n        if (object.positiveIntValue !== undefined &&\n            object.positiveIntValue !== null) {\n            message.positiveIntValue = object.positiveIntValue;\n        }\n        else {\n            message.positiveIntValue = \"0\";\n        }\n        if (object.negativeIntValue !== undefined &&\n            object.negativeIntValue !== null) {\n            message.negativeIntValue = object.negativeIntValue;\n        }\n        else {\n            message.negativeIntValue = \"0\";\n        }\n        if (object.doubleValue !== undefined && object.doubleValue !== null) {\n            message.doubleValue = object.doubleValue;\n        }\n        else {\n            message.doubleValue = 0;\n        }\n        if (object.stringValue !== undefined && object.stringValue !== null) {\n            message.stringValue = object.stringValue;\n        }\n        else {\n            message.stringValue = new Uint8Array();\n        }\n        if (object.aggregateValue !== undefined && object.aggregateValue !== null) {\n            message.aggregateValue = object.aggregateValue;\n        }\n        else {\n            message.aggregateValue = \"\";\n        }\n        return message;\n    },\n};\nvar baseUninterpretedOption_NamePart = {\n    namePart: \"\",\n    isExtension: false,\n};\nexport var UninterpretedOption_NamePart = {\n    encode: function (message, writer) {\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        if (message.namePart !== \"\") {\n            writer.uint32(10).string(message.namePart);\n        }\n        if (message.isExtension === true) {\n            writer.uint32(16).bool(message.isExtension);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseUninterpretedOption_NamePart);\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.namePart = reader.string();\n                    break;\n                case 2:\n                    message.isExtension = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var message = __assign({}, baseUninterpretedOption_NamePart);\n        if (object.namePart !== undefined && object.namePart !== null) {\n            message.namePart = String(object.namePart);\n        }\n        else {\n            message.namePart = \"\";\n        }\n        if (object.isExtension !== undefined && object.isExtension !== null) {\n            message.isExtension = Boolean(object.isExtension);\n        }\n        else {\n            message.isExtension = false;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        message.namePart !== undefined && (obj.namePart = message.namePart);\n        message.isExtension !== undefined &&\n            (obj.isExtension = message.isExtension);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var message = __assign({}, baseUninterpretedOption_NamePart);\n        if (object.namePart !== undefined && object.namePart !== null) {\n            message.namePart = object.namePart;\n        }\n        else {\n            message.namePart = \"\";\n        }\n        if (object.isExtension !== undefined && object.isExtension !== null) {\n            message.isExtension = object.isExtension;\n        }\n        else {\n            message.isExtension = false;\n        }\n        return message;\n    },\n};\nvar baseSourceCodeInfo = {};\nexport var SourceCodeInfo = {\n    encode: function (message, writer) {\n        var e_91, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.location), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                SourceCodeInfo_Location.encode(v, writer.uint32(10).fork()).ldelim();\n            }\n        }\n        catch (e_91_1) { e_91 = { error: e_91_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_91) throw e_91.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseSourceCodeInfo);\n        message.location = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.location.push(SourceCodeInfo_Location.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_92, _a;\n        var message = __assign({}, baseSourceCodeInfo);\n        message.location = [];\n        if (object.location !== undefined && object.location !== null) {\n            try {\n                for (var _b = __values(object.location), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.location.push(SourceCodeInfo_Location.fromJSON(e));\n                }\n            }\n            catch (e_92_1) { e_92 = { error: e_92_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_92) throw e_92.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.location) {\n            obj.location = message.location.map(function (e) {\n                return e ? SourceCodeInfo_Location.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.location = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_93, _a;\n        var message = __assign({}, baseSourceCodeInfo);\n        message.location = [];\n        if (object.location !== undefined && object.location !== null) {\n            try {\n                for (var _b = __values(object.location), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.location.push(SourceCodeInfo_Location.fromPartial(e));\n                }\n            }\n            catch (e_93_1) { e_93 = { error: e_93_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_93) throw e_93.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseSourceCodeInfo_Location = {\n    path: 0,\n    span: 0,\n    leadingComments: \"\",\n    trailingComments: \"\",\n    leadingDetachedComments: \"\",\n};\nexport var SourceCodeInfo_Location = {\n    encode: function (message, writer) {\n        var e_94, _a, e_95, _b, e_96, _c;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        writer.uint32(10).fork();\n        try {\n            for (var _d = __values(message.path), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var v = _e.value;\n                writer.int32(v);\n            }\n        }\n        catch (e_94_1) { e_94 = { error: e_94_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n            }\n            finally { if (e_94) throw e_94.error; }\n        }\n        writer.ldelim();\n        writer.uint32(18).fork();\n        try {\n            for (var _f = __values(message.span), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var v = _g.value;\n                writer.int32(v);\n            }\n        }\n        catch (e_95_1) { e_95 = { error: e_95_1 }; }\n        finally {\n            try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n            }\n            finally { if (e_95) throw e_95.error; }\n        }\n        writer.ldelim();\n        if (message.leadingComments !== \"\") {\n            writer.uint32(26).string(message.leadingComments);\n        }\n        if (message.trailingComments !== \"\") {\n            writer.uint32(34).string(message.trailingComments);\n        }\n        try {\n            for (var _h = __values(message.leadingDetachedComments), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var v = _j.value;\n                writer.uint32(50).string(v);\n            }\n        }\n        catch (e_96_1) { e_96 = { error: e_96_1 }; }\n        finally {\n            try {\n                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n            }\n            finally { if (e_96) throw e_96.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseSourceCodeInfo_Location);\n        message.path = [];\n        message.span = [];\n        message.leadingDetachedComments = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.path.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.path.push(reader.int32());\n                    }\n                    break;\n                case 2:\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.span.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.span.push(reader.int32());\n                    }\n                    break;\n                case 3:\n                    message.leadingComments = reader.string();\n                    break;\n                case 4:\n                    message.trailingComments = reader.string();\n                    break;\n                case 6:\n                    message.leadingDetachedComments.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_97, _a, e_98, _b, e_99, _c;\n        var message = __assign({}, baseSourceCodeInfo_Location);\n        message.path = [];\n        message.span = [];\n        message.leadingDetachedComments = [];\n        if (object.path !== undefined && object.path !== null) {\n            try {\n                for (var _d = __values(object.path), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var e = _e.value;\n                    message.path.push(Number(e));\n                }\n            }\n            catch (e_97_1) { e_97 = { error: e_97_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_97) throw e_97.error; }\n            }\n        }\n        if (object.span !== undefined && object.span !== null) {\n            try {\n                for (var _f = __values(object.span), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var e = _g.value;\n                    message.span.push(Number(e));\n                }\n            }\n            catch (e_98_1) { e_98 = { error: e_98_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_98) throw e_98.error; }\n            }\n        }\n        if (object.leadingComments !== undefined &&\n            object.leadingComments !== null) {\n            message.leadingComments = String(object.leadingComments);\n        }\n        else {\n            message.leadingComments = \"\";\n        }\n        if (object.trailingComments !== undefined &&\n            object.trailingComments !== null) {\n            message.trailingComments = String(object.trailingComments);\n        }\n        else {\n            message.trailingComments = \"\";\n        }\n        if (object.leadingDetachedComments !== undefined &&\n            object.leadingDetachedComments !== null) {\n            try {\n                for (var _h = __values(object.leadingDetachedComments), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.leadingDetachedComments.push(String(e));\n                }\n            }\n            catch (e_99_1) { e_99 = { error: e_99_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                }\n                finally { if (e_99) throw e_99.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.path) {\n            obj.path = message.path.map(function (e) { return e; });\n        }\n        else {\n            obj.path = [];\n        }\n        if (message.span) {\n            obj.span = message.span.map(function (e) { return e; });\n        }\n        else {\n            obj.span = [];\n        }\n        message.leadingComments !== undefined &&\n            (obj.leadingComments = message.leadingComments);\n        message.trailingComments !== undefined &&\n            (obj.trailingComments = message.trailingComments);\n        if (message.leadingDetachedComments) {\n            obj.leadingDetachedComments = message.leadingDetachedComments.map(function (e) { return e; });\n        }\n        else {\n            obj.leadingDetachedComments = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_100, _a, e_101, _b, e_102, _c;\n        var message = __assign({}, baseSourceCodeInfo_Location);\n        message.path = [];\n        message.span = [];\n        message.leadingDetachedComments = [];\n        if (object.path !== undefined && object.path !== null) {\n            try {\n                for (var _d = __values(object.path), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var e = _e.value;\n                    message.path.push(e);\n                }\n            }\n            catch (e_100_1) { e_100 = { error: e_100_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_100) throw e_100.error; }\n            }\n        }\n        if (object.span !== undefined && object.span !== null) {\n            try {\n                for (var _f = __values(object.span), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var e = _g.value;\n                    message.span.push(e);\n                }\n            }\n            catch (e_101_1) { e_101 = { error: e_101_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_101) throw e_101.error; }\n            }\n        }\n        if (object.leadingComments !== undefined &&\n            object.leadingComments !== null) {\n            message.leadingComments = object.leadingComments;\n        }\n        else {\n            message.leadingComments = \"\";\n        }\n        if (object.trailingComments !== undefined &&\n            object.trailingComments !== null) {\n            message.trailingComments = object.trailingComments;\n        }\n        else {\n            message.trailingComments = \"\";\n        }\n        if (object.leadingDetachedComments !== undefined &&\n            object.leadingDetachedComments !== null) {\n            try {\n                for (var _h = __values(object.leadingDetachedComments), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var e = _j.value;\n                    message.leadingDetachedComments.push(e);\n                }\n            }\n            catch (e_102_1) { e_102 = { error: e_102_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                }\n                finally { if (e_102) throw e_102.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseGeneratedCodeInfo = {};\nexport var GeneratedCodeInfo = {\n    encode: function (message, writer) {\n        var e_103, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        try {\n            for (var _b = __values(message.annotation), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                GeneratedCodeInfo_Annotation.encode(v, writer.uint32(10).fork()).ldelim();\n            }\n        }\n        catch (e_103_1) { e_103 = { error: e_103_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_103) throw e_103.error; }\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseGeneratedCodeInfo);\n        message.annotation = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.annotation.push(GeneratedCodeInfo_Annotation.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_104, _a;\n        var message = __assign({}, baseGeneratedCodeInfo);\n        message.annotation = [];\n        if (object.annotation !== undefined && object.annotation !== null) {\n            try {\n                for (var _b = __values(object.annotation), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.annotation.push(GeneratedCodeInfo_Annotation.fromJSON(e));\n                }\n            }\n            catch (e_104_1) { e_104 = { error: e_104_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_104) throw e_104.error; }\n            }\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.annotation) {\n            obj.annotation = message.annotation.map(function (e) {\n                return e ? GeneratedCodeInfo_Annotation.toJSON(e) : undefined;\n            });\n        }\n        else {\n            obj.annotation = [];\n        }\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_105, _a;\n        var message = __assign({}, baseGeneratedCodeInfo);\n        message.annotation = [];\n        if (object.annotation !== undefined && object.annotation !== null) {\n            try {\n                for (var _b = __values(object.annotation), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.annotation.push(GeneratedCodeInfo_Annotation.fromPartial(e));\n                }\n            }\n            catch (e_105_1) { e_105 = { error: e_105_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_105) throw e_105.error; }\n            }\n        }\n        return message;\n    },\n};\nvar baseGeneratedCodeInfo_Annotation = {\n    path: 0,\n    sourceFile: \"\",\n    begin: 0,\n    end: 0,\n};\nexport var GeneratedCodeInfo_Annotation = {\n    encode: function (message, writer) {\n        var e_106, _a;\n        if (writer === void 0) { writer = _m0.Writer.create(); }\n        writer.uint32(10).fork();\n        try {\n            for (var _b = __values(message.path), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var v = _c.value;\n                writer.int32(v);\n            }\n        }\n        catch (e_106_1) { e_106 = { error: e_106_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_106) throw e_106.error; }\n        }\n        writer.ldelim();\n        if (message.sourceFile !== \"\") {\n            writer.uint32(18).string(message.sourceFile);\n        }\n        if (message.begin !== 0) {\n            writer.uint32(24).int32(message.begin);\n        }\n        if (message.end !== 0) {\n            writer.uint32(32).int32(message.end);\n        }\n        return writer;\n    },\n    decode: function (input, length) {\n        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = __assign({}, baseGeneratedCodeInfo_Annotation);\n        message.path = [];\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.path.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.path.push(reader.int32());\n                    }\n                    break;\n                case 2:\n                    message.sourceFile = reader.string();\n                    break;\n                case 3:\n                    message.begin = reader.int32();\n                    break;\n                case 4:\n                    message.end = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON: function (object) {\n        var e_107, _a;\n        var message = __assign({}, baseGeneratedCodeInfo_Annotation);\n        message.path = [];\n        if (object.path !== undefined && object.path !== null) {\n            try {\n                for (var _b = __values(object.path), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.path.push(Number(e));\n                }\n            }\n            catch (e_107_1) { e_107 = { error: e_107_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_107) throw e_107.error; }\n            }\n        }\n        if (object.sourceFile !== undefined && object.sourceFile !== null) {\n            message.sourceFile = String(object.sourceFile);\n        }\n        else {\n            message.sourceFile = \"\";\n        }\n        if (object.begin !== undefined && object.begin !== null) {\n            message.begin = Number(object.begin);\n        }\n        else {\n            message.begin = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = Number(object.end);\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n    toJSON: function (message) {\n        var obj = {};\n        if (message.path) {\n            obj.path = message.path.map(function (e) { return e; });\n        }\n        else {\n            obj.path = [];\n        }\n        message.sourceFile !== undefined && (obj.sourceFile = message.sourceFile);\n        message.begin !== undefined && (obj.begin = message.begin);\n        message.end !== undefined && (obj.end = message.end);\n        return obj;\n    },\n    fromPartial: function (object) {\n        var e_108, _a;\n        var message = __assign({}, baseGeneratedCodeInfo_Annotation);\n        message.path = [];\n        if (object.path !== undefined && object.path !== null) {\n            try {\n                for (var _b = __values(object.path), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var e = _c.value;\n                    message.path.push(e);\n                }\n            }\n            catch (e_108_1) { e_108 = { error: e_108_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_108) throw e_108.error; }\n            }\n        }\n        if (object.sourceFile !== undefined && object.sourceFile !== null) {\n            message.sourceFile = object.sourceFile;\n        }\n        else {\n            message.sourceFile = \"\";\n        }\n        if (object.begin !== undefined && object.begin !== null) {\n            message.begin = object.begin;\n        }\n        else {\n            message.begin = 0;\n        }\n        if (object.end !== undefined && object.end !== null) {\n            message.end = object.end;\n        }\n        else {\n            message.end = 0;\n        }\n        return message;\n    },\n};\nvar globalThis = (function () {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nvar atob = globalThis.atob ||\n    (function (b64) { return globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"); });\nfunction bytesFromBase64(b64) {\n    var bin = atob(b64);\n    var arr = new Uint8Array(bin.length);\n    for (var i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nvar btoa = globalThis.btoa ||\n    (function (bin) { return globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"); });\nfunction base64FromBytes(arr) {\n    var e_109, _a;\n    var bin = [];\n    try {\n        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n            var byte = arr_1_1.value;\n            bin.push(String.fromCharCode(byte));\n        }\n    }\n    catch (e_109_1) { e_109 = { error: e_109_1 }; }\n    finally {\n        try {\n            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n        }\n        finally { if (e_109) throw e_109.error; }\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (_m0.util.Long !== Long) {\n    _m0.util.Long = Long;\n    _m0.configure();\n}\n"],"names":["FieldDescriptorProto_Type","FieldDescriptorProto_Label","FileOptions_OptimizeMode","FieldOptions_CType","FieldOptions_JSType","MethodOptions_IdempotencyLevel","globalThis","self","window","g","atob","btoa"],"sourceRoot":""}